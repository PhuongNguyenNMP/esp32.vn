{
    "docs": [
        {
            "location": "/",
            "text": "Gi\u1edbi thi\u1ec7u\n#\n\n\nTrang Web n\u00e0y x\u00e2y d\u1ef1ng nh\u1eb1m m\u1ee5c \u0111\u00edch t\u1ed5ng h\u1ee3p c\u00e1c ki\u1ebfn th\u1ee9c l\u1eadp tr\u00ecnh ESP32 Ti\u1ebfng Vi\u1ec7t \u0111\u1ec3 h\u1ed7 tr\u1ee3 c\u1ed3ng \u0111\u1ed3ng ph\u00e1t tri\u1ec3n Internet Of Things Vi\u1ec7t Nam.\n\n\nN\u1ed9i dung Website s\u1ebd t\u1ed5ng h\u1ee3p nhi\u1ec1u nh\u1ea5t c\u00f3 th\u1ec3 c\u00e1c \u1ee9ng d\u1ee5ng, platform li\u00ean quan \u0111\u1ebfn ESP32 \n\n\n\n\nESP32 ESP-IDF\n vi\u1ebft t\u1eaft c\u1ee7a ESP \nInternet Of Things Development Framework\n - L\u00e0 framework ch\u00ednh th\u1ee9c t\u1eeb \nEspressif Systems\n, h\u1ed7 tr\u1ee3 l\u1eadp tr\u00ecnh \u1ee9ng d\u1ee5ng cho ESP32 d\u1ef1a tr\u00ean FreeRTOS v\u00e0 t\u00edch h\u1ee3p c\u00e1c component nh\u01b0: LWIP, Filesystem, \u2026\n\n\n\n\n\n\n\n\nESP32 Arduino\n l\u00e0 th\u01b0 vi\u1ec7n h\u1ed7 tr\u1ee3 l\u1eadp tr\u00ecnh cho ESP32 trong m\u00f4i tr\u01b0\u1eddng th\u00e2n thi\u1ec7n Arduino. T\u01b0\u01a1ng t\u1ef1 nh\u01b0 Arduino cho ESP8266, ESP32 Arduino h\u1ed7 tr\u1ee3 h\u1ea7u h\u1ebft c\u00e1c t\u00ednh n\u0103ng v\u00e0 h\u00e0m th\u1ef1c thi nh\u01b0 Arduino th\u00f4ng th\u01b0\u1eddng, \u0111\u1ed3ng th\u1eddi h\u1ed7 tr\u1ee3 th\u00eam c\u00e1c h\u00e0m/t\u00ednh n\u0103ng v\u1ec1 \nWiFi\n, \nBLE\n v\u00e0 \nNetwork\n\n\n\n\n\n\n\u0110\u1eb7c \u0111i\u1ec3m v\u00e0 t\u00ednh n\u0103ng\n#\n\n\n\n\nK\u1ebft n\u1ed1i kh\u00f4ng d\u00e2y:\n\n\nWi-Fi:\n 150.0 Mbps data rate with HT40 (40 MHz channel width, 400 ns guard interval, 1 spatial stream, 64-QAM, 5/6 coding rate).\n\n\nBluetooth:\n Bluetooth LE (low energy) & legacy Bluetooth.\n\n\nProcessor:\n Xtensa Dual-Core 32-bit LX6 microprocessor, running at 160 or 240\u00a0MHz, and with performance characteristics of up to 600 DMIPS. (You can have your own application processor without having to worry about the Wi-Fi portion.)\n\n\nLow power:\n Low power options to ensure that you can still do ADC conversions, computation, level thresholds, etc., while in deep sleep.\n\n\nROM:\n 448 KByte ROM.\n\n\nRAM:\n 520 kByte SRAM.\n\n\nPeripheral input/output:\n Rich peripheral interface with DMA that includes capacitive touch, ADCs (analog-to-digital converter), DACs (digital-to-analog converter), I\u00b2C (Inter-Integrated Circuit), UART (universal asynchronous receiver/transmitter), SPI (Serial Peripheral Interface), I\u00b2S (Integrated Interchip Sound), RMII (reduced media-independent interface), and PWM (Pulse Width Modulation).\n\n\nSecurity:\n Hardware accelerators for AES and SSL/TLS.\n\n\n\n\nPinout\n#\n\n\n\n\nCommunity Discussion\n#\n\n\nTools Code\n#\n\n\nChips Boards\n#\n\n\nChips\n#\n\n\n\n\nESP31B\n \u2014 Used for beta testing purposes on the pre-release ESP-WROOM-03 module.\n\n\nESP32-D0WDQ6\n \u2014 Initial chip release of the ESP32 series. [John Lee said \u201cthere are variations on all of these\u201d][2] with regard to the trailing attribute identifier code.\n\n\nD\n: Dual-core\n\n\n0\n: No internal flash\n\n\nW\n: Wi-Fi\n\n\nD\n: Dual-mode Bluetooth\n\n\nQ\n: Quad Flat No-leads (QFN) package\n\n\n6\n: 6\u00a0mm \u00d7 6\u00a0mm package body size\n\n\n\n\n\n\n\n\nModule Boards\n#\n\n\n\n\nEspressif ESP-WROOM-03\n \u2014\u00a0Pre-release beta test module that used the ESP31B.\n\n\nEspressif ESP-WROOM-32\n \u2014\u00a0Official release module board [created by Espressif][3].\n\n\nAI-Thinker ESP3212\n \u2014\u00a0Module based on the form factor of the AI-Thinker ESP-12F module.\n\n\n\n\nOther Boards\n#\n\n\n\n\nEspressif ESP_Module_Testboard\n \u2014 Simple break-out board included with ESP-WROOM-03 beta modules.\n\n\nEspressif ESP32_Demo Board_V2\n \u2014 A large development demo board created by Espressif for the ESP-WROOM-32 module.\n\n\nHydraBus HydraESP32\n \u2014 HydraESP32 HydraBus v1.0 shield/breakout board for ESP-WROOM-32. This shield can be used with or without a HydraBus board.\n\n\nESP32-MODULE-KIT V1.0\n \u2014 [From vendor unknown, a NodeMCU-like board that incorporates an ESP32 module.][4]",
            "title": "Trang ch\u1ee7"
        },
        {
            "location": "/#gioi-thieu",
            "text": "Trang Web n\u00e0y x\u00e2y d\u1ef1ng nh\u1eb1m m\u1ee5c \u0111\u00edch t\u1ed5ng h\u1ee3p c\u00e1c ki\u1ebfn th\u1ee9c l\u1eadp tr\u00ecnh ESP32 Ti\u1ebfng Vi\u1ec7t \u0111\u1ec3 h\u1ed7 tr\u1ee3 c\u1ed3ng \u0111\u1ed3ng ph\u00e1t tri\u1ec3n Internet Of Things Vi\u1ec7t Nam.  N\u1ed9i dung Website s\u1ebd t\u1ed5ng h\u1ee3p nhi\u1ec1u nh\u1ea5t c\u00f3 th\u1ec3 c\u00e1c \u1ee9ng d\u1ee5ng, platform li\u00ean quan \u0111\u1ebfn ESP32    ESP32 ESP-IDF  vi\u1ebft t\u1eaft c\u1ee7a ESP  Internet Of Things Development Framework  - L\u00e0 framework ch\u00ednh th\u1ee9c t\u1eeb  Espressif Systems , h\u1ed7 tr\u1ee3 l\u1eadp tr\u00ecnh \u1ee9ng d\u1ee5ng cho ESP32 d\u1ef1a tr\u00ean FreeRTOS v\u00e0 t\u00edch h\u1ee3p c\u00e1c component nh\u01b0: LWIP, Filesystem, \u2026     ESP32 Arduino  l\u00e0 th\u01b0 vi\u1ec7n h\u1ed7 tr\u1ee3 l\u1eadp tr\u00ecnh cho ESP32 trong m\u00f4i tr\u01b0\u1eddng th\u00e2n thi\u1ec7n Arduino. T\u01b0\u01a1ng t\u1ef1 nh\u01b0 Arduino cho ESP8266, ESP32 Arduino h\u1ed7 tr\u1ee3 h\u1ea7u h\u1ebft c\u00e1c t\u00ednh n\u0103ng v\u00e0 h\u00e0m th\u1ef1c thi nh\u01b0 Arduino th\u00f4ng th\u01b0\u1eddng, \u0111\u1ed3ng th\u1eddi h\u1ed7 tr\u1ee3 th\u00eam c\u00e1c h\u00e0m/t\u00ednh n\u0103ng v\u1ec1  WiFi ,  BLE  v\u00e0  Network",
            "title": "Gi\u1edbi thi\u1ec7u"
        },
        {
            "location": "/#ac-iem-va-tinh-nang",
            "text": "K\u1ebft n\u1ed1i kh\u00f4ng d\u00e2y:  Wi-Fi:  150.0 Mbps data rate with HT40 (40 MHz channel width, 400 ns guard interval, 1 spatial stream, 64-QAM, 5/6 coding rate).  Bluetooth:  Bluetooth LE (low energy) & legacy Bluetooth.  Processor:  Xtensa Dual-Core 32-bit LX6 microprocessor, running at 160 or 240\u00a0MHz, and with performance characteristics of up to 600 DMIPS. (You can have your own application processor without having to worry about the Wi-Fi portion.)  Low power:  Low power options to ensure that you can still do ADC conversions, computation, level thresholds, etc., while in deep sleep.  ROM:  448 KByte ROM.  RAM:  520 kByte SRAM.  Peripheral input/output:  Rich peripheral interface with DMA that includes capacitive touch, ADCs (analog-to-digital converter), DACs (digital-to-analog converter), I\u00b2C (Inter-Integrated Circuit), UART (universal asynchronous receiver/transmitter), SPI (Serial Peripheral Interface), I\u00b2S (Integrated Interchip Sound), RMII (reduced media-independent interface), and PWM (Pulse Width Modulation).  Security:  Hardware accelerators for AES and SSL/TLS.",
            "title": "\u0110\u1eb7c \u0111i\u1ec3m v\u00e0 t\u00ednh n\u0103ng"
        },
        {
            "location": "/#pinout",
            "text": "",
            "title": "Pinout"
        },
        {
            "location": "/#community-discussion",
            "text": "",
            "title": "Community Discussion"
        },
        {
            "location": "/#tools-code",
            "text": "",
            "title": "Tools Code"
        },
        {
            "location": "/#chips-boards",
            "text": "",
            "title": "Chips Boards"
        },
        {
            "location": "/#chips",
            "text": "ESP31B  \u2014 Used for beta testing purposes on the pre-release ESP-WROOM-03 module.  ESP32-D0WDQ6  \u2014 Initial chip release of the ESP32 series. [John Lee said \u201cthere are variations on all of these\u201d][2] with regard to the trailing attribute identifier code.  D : Dual-core  0 : No internal flash  W : Wi-Fi  D : Dual-mode Bluetooth  Q : Quad Flat No-leads (QFN) package  6 : 6\u00a0mm \u00d7 6\u00a0mm package body size",
            "title": "Chips"
        },
        {
            "location": "/#module-boards",
            "text": "Espressif ESP-WROOM-03  \u2014\u00a0Pre-release beta test module that used the ESP31B.  Espressif ESP-WROOM-32  \u2014\u00a0Official release module board [created by Espressif][3].  AI-Thinker ESP3212  \u2014\u00a0Module based on the form factor of the AI-Thinker ESP-12F module.",
            "title": "Module Boards"
        },
        {
            "location": "/#other-boards",
            "text": "Espressif ESP_Module_Testboard  \u2014 Simple break-out board included with ESP-WROOM-03 beta modules.  Espressif ESP32_Demo Board_V2  \u2014 A large development demo board created by Espressif for the ESP-WROOM-32 module.  HydraBus HydraESP32  \u2014 HydraESP32 HydraBus v1.0 shield/breakout board for ESP-WROOM-32. This shield can be used with or without a HydraBus board.  ESP32-MODULE-KIT V1.0  \u2014 [From vendor unknown, a NodeMCU-like board that incorporates an ESP32 module.][4]",
            "title": "Other Boards"
        },
        {
            "location": "/arduino/arduino/",
            "text": "Arduino core cho ESP32 WiFi chip\n#\n\n\n\u0110\u00e2y l\u00e0 m\u1ed9t d\u1ef1 \u00e1n m\u00e3 ngu\u1ed3n m\u1edf gi\u00fap h\u1ed7 tr\u1ee3 m\u00f4i tr\u01b0\u1eddng ph\u00e1t tri\u1ec3n Arduino cho ESP32. Gi\u00fap b\u1ea1n c\u00f3 th\u1ec3 vi\u1ebft 1 Sketches s\u1eed d\u1ee5ng c\u00e1c th\u01b0 vi\u1ec7n v\u00e0 h\u00e0m t\u01b0\u01a1ng t\u1ef1 c\u1ee7a Arduino, c\u00f3 th\u1ec3 ch\u1ea1y tr\u1ef1c ti\u1ebfp tr\u00ean ESP32 m\u00e0 kh\u00f4ng c\u1ea7n b\u1ea5t k\u1ef3 Vi \u0111i\u1ec1u khi\u1ec3n n\u00e0o kh\u00e1c.\n\n\nESP32 Arduino core \u0111i k\u00e8m v\u1edbi th\u01b0 vi\u1ec7n k\u1ebft n\u1ed1i WiFi h\u1ed7 tr\u1ee3 TCP, UDP v\u00e0 c\u00e1c \u1ee9ng d\u1ee5ng HTTP, mDNS, SSDP, DNS Servers. Ngo\u00e0i ra c\u00f2n c\u00f3 th\u1ec3 th\u1ef1c hi\u1ec7n c\u1eadp nh\u1eadt OTA, s\u1eed d\u1ee5ng Filesystem d\u00f9ng b\u1ed9 nh\u1edb Flash hay th\u1ebb SD, \u0111i\u1ec1u khi\u1ec3n servos, ngo\u1ea1i vi SPI, I2C.\n\n\nESP32 Arduino h\u1ed7 tr\u1ee3 g\u1ea7n nh\u01b0 t\u1ea5t c\u1ea3 c\u00e1c h\u00e0m/t\u00ednh n\u0103ng gi\u1ed1ng nh\u01b0 ESP8266 Arduino, ngo\u00e0i ra c\u00f2n c\u00f3 th\u00eam BLE, s\u1eed d\u1ee5ng b\u00ean trong ESP-IDF, th\u1ef1c thi c\u00e1c t\u00e1c v\u1ee5 c\u1ee7a FreeRTOS",
            "title": "Gi\u1edbi thi\u1ec7u"
        },
        {
            "location": "/arduino/arduino/#arduino-core-cho-esp32-wifi-chip",
            "text": "\u0110\u00e2y l\u00e0 m\u1ed9t d\u1ef1 \u00e1n m\u00e3 ngu\u1ed3n m\u1edf gi\u00fap h\u1ed7 tr\u1ee3 m\u00f4i tr\u01b0\u1eddng ph\u00e1t tri\u1ec3n Arduino cho ESP32. Gi\u00fap b\u1ea1n c\u00f3 th\u1ec3 vi\u1ebft 1 Sketches s\u1eed d\u1ee5ng c\u00e1c th\u01b0 vi\u1ec7n v\u00e0 h\u00e0m t\u01b0\u01a1ng t\u1ef1 c\u1ee7a Arduino, c\u00f3 th\u1ec3 ch\u1ea1y tr\u1ef1c ti\u1ebfp tr\u00ean ESP32 m\u00e0 kh\u00f4ng c\u1ea7n b\u1ea5t k\u1ef3 Vi \u0111i\u1ec1u khi\u1ec3n n\u00e0o kh\u00e1c.  ESP32 Arduino core \u0111i k\u00e8m v\u1edbi th\u01b0 vi\u1ec7n k\u1ebft n\u1ed1i WiFi h\u1ed7 tr\u1ee3 TCP, UDP v\u00e0 c\u00e1c \u1ee9ng d\u1ee5ng HTTP, mDNS, SSDP, DNS Servers. Ngo\u00e0i ra c\u00f2n c\u00f3 th\u1ec3 th\u1ef1c hi\u1ec7n c\u1eadp nh\u1eadt OTA, s\u1eed d\u1ee5ng Filesystem d\u00f9ng b\u1ed9 nh\u1edb Flash hay th\u1ebb SD, \u0111i\u1ec1u khi\u1ec3n servos, ngo\u1ea1i vi SPI, I2C.  ESP32 Arduino h\u1ed7 tr\u1ee3 g\u1ea7n nh\u01b0 t\u1ea5t c\u1ea3 c\u00e1c h\u00e0m/t\u00ednh n\u0103ng gi\u1ed1ng nh\u01b0 ESP8266 Arduino, ngo\u00e0i ra c\u00f2n c\u00f3 th\u00eam BLE, s\u1eed d\u1ee5ng b\u00ean trong ESP-IDF, th\u1ef1c thi c\u00e1c t\u00e1c v\u1ee5 c\u1ee7a FreeRTOS",
            "title": "Arduino core cho ESP32 WiFi chip"
        },
        {
            "location": "/arduino/install/",
            "text": "C\u00e0i \u0111\u1eb7t\n#\n\n\nS\u1eed d\u1ee5ng git version\n#\n\n\nPh\u01b0\u01a1ng \u00e1n c\u00e0i \u0111\u1eb7t n\u00e0y khuy\u00ean d\u00f9ng cho nh\u1eefng ng\u01b0\u1eddi c\u00f3 th\u1ec3 \u0111\u00f3ng g\u00f3p v\u00e0o d\u1ef1 \u00e1n Arduino cho ESP32 v\u00e0 developers.\n\n\nChu\u1ea9n b\u1ecb\n#\n\n\n\n\nArduino 1.6.8 (hay m\u1edbi h\u01a1n, n\u1ebfu b\u1ea1n bi\u1ebft b\u1ea1n \u0111ang l\u00e0m g\u00ec) t\u1eeb \nhttps://arduino.cc\n\n\ngit\n\n\npython 2.7\n\n\nterminal, console, or command prompt (ph\u1ee5 thu\u1ed9c h\u1ec7 \u0111i\u1ec1u h\u00e0nh c\u1ee7a b\u1ea1n)\n\n\nK\u1ebft n\u1ed1i Internet\n\n\n\n\nH\u01b0\u1edbng d\u1eabn\n#\n\n\n\n\nM\u1edf \nconsole\n v\u00e0 cd \u0111\u1ebfn th\u01b0 m\u1ee5c Arduino. N\u00f3 c\u00f3 th\u1ec3 l\u00e0 th\u01b0 m\u1ee5c \nsketchbook\n (th\u01b0\u1eddng l\u00e0 \n<Documents>/Arduino\n), hay th\u01b0 m\u1ee5c c\u1ee7a \u1ee8ng d\u1ee5ng Arduino, t\u00f9y b\u1ea1n ch\u1ecdn.\n\n\nClone repository n\u00e0y \u0111\u1ebfn th\u01b0 m\u1ee5c \nhardware/espressif/esp32\n. Ho\u1eb7c b\u1ea1n c\u00f3 th\u1ec3 clone v\u00e0o n\u01a1i n\u00e0o \u0111\u00f3 v\u00e0 t\u1ea1o symlink b\u1eb1ng \nln -s\n, n\u1ebfu H\u1ec7 \u0111i\u1ec1u h\u00e0nh h\u1ed7 tr\u1ee3.\n\n\n\n\ncd hardware\nmkdir espressif\ncd espressif\ngit clone https://github.com/espressif/arduino-esp32.git esp32\n\n\n\n\nC\u1ea5u tr\u00fac d\u1ef1 \u00e1n sau khi b\u1ea1n th\u1ef1c hi\u1ec7n xong:\n\n\nArduino\n    |- hardware\n    |- espressif\n        |- esp32\n            |- bootloaders\n            |- cores\n            |- doc\n            |- libraries\n            |- package\n            |- tests\n            |- tools\n            |- variants\n            |- platform.txt\n            |- programmers.txt\n            |- README.md\n            |- boards.txt\n            `- LICENSE\n\n\n\n\n\n\nT\u1ea3i binary tools\n\n\n\n\ncd esp32/tools\npython get.py\n\n\n\n\n\n\nKh\u1edfi \u0111\u1ed9ng l\u1ea1i Arduino",
            "title": "C\u00e0i \u0111\u1eb7t"
        },
        {
            "location": "/arduino/install/#cai-at",
            "text": "",
            "title": "C\u00e0i \u0111\u1eb7t"
        },
        {
            "location": "/arduino/install/#su-dung-git-version",
            "text": "Ph\u01b0\u01a1ng \u00e1n c\u00e0i \u0111\u1eb7t n\u00e0y khuy\u00ean d\u00f9ng cho nh\u1eefng ng\u01b0\u1eddi c\u00f3 th\u1ec3 \u0111\u00f3ng g\u00f3p v\u00e0o d\u1ef1 \u00e1n Arduino cho ESP32 v\u00e0 developers.",
            "title": "S\u1eed d\u1ee5ng git version"
        },
        {
            "location": "/arduino/install/#chuan-bi",
            "text": "Arduino 1.6.8 (hay m\u1edbi h\u01a1n, n\u1ebfu b\u1ea1n bi\u1ebft b\u1ea1n \u0111ang l\u00e0m g\u00ec) t\u1eeb  https://arduino.cc  git  python 2.7  terminal, console, or command prompt (ph\u1ee5 thu\u1ed9c h\u1ec7 \u0111i\u1ec1u h\u00e0nh c\u1ee7a b\u1ea1n)  K\u1ebft n\u1ed1i Internet",
            "title": "Chu\u1ea9n b\u1ecb"
        },
        {
            "location": "/arduino/install/#huong-dan",
            "text": "M\u1edf  console  v\u00e0 cd \u0111\u1ebfn th\u01b0 m\u1ee5c Arduino. N\u00f3 c\u00f3 th\u1ec3 l\u00e0 th\u01b0 m\u1ee5c  sketchbook  (th\u01b0\u1eddng l\u00e0  <Documents>/Arduino ), hay th\u01b0 m\u1ee5c c\u1ee7a \u1ee8ng d\u1ee5ng Arduino, t\u00f9y b\u1ea1n ch\u1ecdn.  Clone repository n\u00e0y \u0111\u1ebfn th\u01b0 m\u1ee5c  hardware/espressif/esp32 . Ho\u1eb7c b\u1ea1n c\u00f3 th\u1ec3 clone v\u00e0o n\u01a1i n\u00e0o \u0111\u00f3 v\u00e0 t\u1ea1o symlink b\u1eb1ng  ln -s , n\u1ebfu H\u1ec7 \u0111i\u1ec1u h\u00e0nh h\u1ed7 tr\u1ee3.   cd hardware\nmkdir espressif\ncd espressif\ngit clone https://github.com/espressif/arduino-esp32.git esp32  C\u1ea5u tr\u00fac d\u1ef1 \u00e1n sau khi b\u1ea1n th\u1ef1c hi\u1ec7n xong:  Arduino\n    |- hardware\n    |- espressif\n        |- esp32\n            |- bootloaders\n            |- cores\n            |- doc\n            |- libraries\n            |- package\n            |- tests\n            |- tools\n            |- variants\n            |- platform.txt\n            |- programmers.txt\n            |- README.md\n            |- boards.txt\n            `- LICENSE   T\u1ea3i binary tools   cd esp32/tools\npython get.py   Kh\u1edfi \u0111\u1ed9ng l\u1ea1i Arduino",
            "title": "H\u01b0\u1edbng d\u1eabn"
        },
        {
            "location": "/esp-idf/esp-idf/",
            "text": "ESP-IDF - Espressif IoT Development Framework\n#",
            "title": "Gi\u1edbi thi\u1ec7u"
        },
        {
            "location": "/esp-idf/esp-idf/#esp-idf-espressif-iot-development-framework",
            "text": "",
            "title": "ESP-IDF - Espressif IoT Development Framework"
        },
        {
            "location": "/esp-idf/basic/build-system/",
            "text": "H\u1ec7 th\u1ed1ng bi\u00ean d\u1ecbch cho ESP-IDF\n#\n\n\nN\u1ed9i dung t\u00e0i li\u1ec7u n\u00e0y gi\u1ea3i th\u00edch c\u00e1ch th\u1ee9c bi\u00ean d\u1ecbch cho Espressif IoT Development Framework v\u00e0 nguy\u00ean l\u00fd l\u00e0m vi\u1ec7c c\u1ee7a \u201ccomponents\u201d\n\n\n\u0110\u1ecdc t\u00e0i li\u1ec7u n\u00e0y n\u1ebfu b\u1ea1n mu\u1ed1n bi\u1ebft l\u00e0m th\u1ebf n\u00e0o \u0111\u1ec3 t\u1ed5 ch\u1ee9c m\u1ed9t d\u1ef1 \u00e1n \nESP-IDF\n m\u1edbi\n\n\nB\u1ea1n n\u00ean xem qua d\u1ef1 \u00e1n m\u1eabu \nesp-idf-template\n \u0111\u1ec3 c\u00f3 c\u00e1i nh\u00ecn kh\u1edfi \u0111\u1ea7u t\u1ed1t h\u01a1n.\n\n\nT\u1ed5ng quan\n#\n\n\nM\u1ed9t d\u1ef1 \u00e1n \nESP-IDF\n c\u00f3 th\u1ec3 h\u1ed7n h\u1ee3p nhi\u1ec1u \u201ccomponents\u201d. V\u00ed d\u1ee5: v\u1edbi 1 Web Server hi\u1ec3n th\u1ecb \u0111\u1ed9 \u1ea9m hi\u1ec7n t\u1ea1i, ch\u00fang ta c\u1ea7n: \n\n\n\n\nTh\u01b0 vi\u1ec7n c\u01a1 b\u1ea3n cho ESP32 (libc, rom bindings v.v..)\n\n\nWiFi drivers\n\n\nTCP/IP stack\n\n\nH\u1ec7 \u0111i\u1ec1u h\u00e0nh FreeRTOS\n\n\nM\u1ed9t webserver\n\n\nM\u1ed9t driver cho c\u1ea3m bi\u1ebfn \u0111\u1ed9 \u1ea9m\n\n\nCh\u01b0\u01a1ng tr\u00ecnh ch\u00ednh \u0111\u1ec3 gh\u00e9p n\u1ed1i t\u1ea5t c\u1ea3\n\n\n\n\nESP-IDF\n l\u00e0m cho c\u00e1c \u201ccomponent\u201d r\u00f5 r\u00e0ng v\u00e0 d\u1ec5 d\u00e0ng c\u1ea5u h\u00ecnh. \u0110\u1ec3 l\u00e0m \u0111\u01b0\u1ee3c \u0111i\u1ec1u \u0111\u00f3, khi m\u1ed9t d\u1ef1 \u00e1n \u0111\u01b0\u1ee3c bi\u00ean so\u1ea1n, m\u00f4i tr\u01b0\u1eddng bi\u00ean d\u1ecbch s\u1ebd t\u00ecm t\u1ea5t c\u1ea3 c\u00e1c th\u00e0nh ph\u1ea7n trong th\u01b0 m\u1ee5c \nESP-IDF\n, c\u00e1c th\u01b0 m\u1ee5c d\u1ef1 \u00e1n v\u00e0 th\u00f4ng tin c\u1ea5u h\u00ecnh c\u1ee7a m\u1ed7i component. N\u00f3 cho ph\u00e9p ng\u01b0\u1eddi s\u1eed d\u1ee5ng c\u00f3 th\u1ec3 c\u1ea5u h\u00ecnh m\u1ed7i l\u1ea7n bi\u00ean d\u1ecbch s\u1eed d\u1ee5ng h\u1ec7 th\u1ed1ng menu d\u1ef1a tr\u00ean v\u0103n b\u1ea3n th\u00e2n thi\u1ec7n \u0111\u1ec3 t\u00f9y ch\u1ec9nh ESP-IDF c\u0169ng nh\u01b0 c\u00e1c th\u00e0nh ph\u1ea7n kh\u00e1c \u0111\u01b0\u1ee3c y\u00eau c\u1ea7u b\u1edfi d\u1ef1 \u00e1n. Sau khi c\u00e1c component \u0111\u01b0\u1ee3c t\u00f9y bi\u1ebfn, ti\u1ebfn tr\u00ecnh bi\u00ean d\u1ecbch s\u1ebd bi\u00ean d\u1ecbch t\u1ea5t c\u1ea3 m\u1ecdi th\u1ee9 v\u00e0o m\u1ed9t t\u1eadp tin cu\u1ed1i c\u00f9ng, \u0111\u1ec3 c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c n\u1ea1p v\u00e0o b\u1ea3ng m\u1ea1ch ESP32.\n\n\nM\u1ed9t d\u1ef1 \u00e1n nh\u01b0 \u0111\u00e3 n\u00f3i tr\u00ean \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a nh\u01b0 l\u00e0 m\u1ed9t th\u01b0 m\u1ee5c, theo \u0111\u00f3 y\u00eau c\u1ea7u t\u1ea5t c\u1ea3 c\u00e1c t\u1eadp tin nh\u01b0 h\u1ec7 th\u1ed1ng th\u01b0 m\u1ee5c b\u00ean d\u01b0\u1edbi kh\u00f4ng bao g\u1ed3m c\u00e1c t\u1eadp tin c\u1ee7a ESP-IDF v\u00e0 toolchain. M\u1ed9t d\u1ef1 \u00e1n \u0111\u01a1n gi\u1ea3n tr\u00f4ng nh\u01b0 sau:\n\n\nmyProject/\n  |--build/\n  |--components/ \n  |   |-- component1/ \n  |   |     |-- component.mk\n  |   |     |-- Kconfig\n  |   |     |-- src1.c\n  |   |-- component2/ \n  |   |     |-- component.mk\n  |   |     |-- Kconfig\n  |   |     |-- src1.c\n  |-- main/       \n      |-- src1.c\n      |-- src2.c\n      `-- Makefile\n\n\n\n\nNh\u01b0 \u0111\u00e3 th\u1ea5y, m\u1ed9t d\u1ef1 \u00e1n c\u00f3 m\u1ed9t th\u01b0 m\u1ee5c con \ncomponents/\n bao g\u1ed3m c\u00e1c \ncomponents\n ch\u1ee9a \u0111\u1ef1ng trong 1 ho\u1eb7c nhi\u1ec1u th\u01b0 m\u1ee5c v\u00e0 c\u00e1c t\u1eadp tin m\u00e3 ngu\u1ed3n cho d\u1ef1 \u00e1n, m\u1eb7c \u0111\u1ecbnh, l\u00e0 th\u01b0 m\u1ee5c \nmain\n. D\u1ef1 \u00e1n c\u0169ng c\u00f3 c\u1ea3 \nMakefile\n, ch\u1ee9a th\u00f4ng tin t\u00ean d\u1ef1 \u00e1n c\u0169ng nh\u01b0 c\u00e1c t\u00f9y ch\u1ecdn bi\u00ean d\u1ecbch. Sau khi bi\u00ean d\u1ecbch, d\u1ef1 \u00e1n s\u1ebd bao g\u1ed3m th\u01b0 m\u1ee5c \nbuild\n bao g\u1ed3m t\u1ea5t c\u1ea3 c\u00e1c object, th\u01b0 vi\u1ec7n \u0111\u01b0\u1ee3c bi\u00ean d\u1ecbch ra, bao g\u1ed3m c\u1ea3 file binary th\u00e0nh ph\u1ea9m cu\u1ed1i c\u00f9ng.\n\n\nM\u1ed7i component s\u1ebd c\u00f3 1 \nMakefile\n g\u1ecdi l\u00e0 \ncomponent.mk\n ch\u1ee9a \u0111\u1ef1ng m\u1ed9t s\u1ed1 \u0111\u1ecbnh ngh\u0129a bi\u00ean d\u1ecbch cho component \u0111\u00f3, bao g\u1ed3m ti\u1ebfn tr\u00ecnh bi\u00ean d\u1ecbch. Component c\u0169ng c\u00f3 th\u1ec3 bao g\u1ed3m \nKconfig\n file, \u0111\u1ecbnh ngh\u0129a nh\u1eefng t\u00f9y ch\u1ecdn cho m\u1ed7i l\u1ea7n bi\u00ean d\u1ecbch, c\u00f3 th\u1ebb c\u1ea5u h\u00ecnh v\u1edbi h\u1ec7 th\u1ed1ng Menu (\nmake menuconfig\n)\n\n\nC\u00e1c bi\u1ebfn ch\u1ee9a trong \nMakefile\n cho d\u1ef1 \u00e1n c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c set b\u1edfi l\u1eadp tr\u00ecnh vi\u00ean:\n\n\n\n\nPROJECT_NAME\n: B\u1eaft bu\u1ed9c. T\u00ean c\u1ee7a d\u1ef1 \u00e1n\n\n\nBUILD_DIR_BASE\n: Th\u01b0 m\u1ee5c ch\u1ee9a t\u1ea5t c\u1ea3 c\u00e1c object, th\u01b0 vi\u1ec7n, binary \u0111\u01b0\u1ee3c bi\u00ean d\u1ecbch ra. M\u1eb7c \u0111\u1ecbnh \n$(PROJECT_PATH)/build\n\n\nCOMPONENT_DIRS\n: Th\u01b0 m\u1ee5c h\u1ec7 th\u1ed1ng bien d\u1ecbch s\u1ebd t\u00ecm ki\u1ebfm c\u00e1c component. M\u1eb7c \u0111\u1ecbnh \ncomponent/\n trong d\u1ef1 \u00e1n ESP-IDF\n\n\nCOMPONENTS\n: Danh s\u00e1ch c\u00e1c t\u00ean component s\u1ebd bi\u00ean d\u1ecbch, m\u1eb7c \u0111\u1ecbnh l\u00e0 t\u1ea5t c\u1ea3 c\u00e1c th\u01b0 m\u1ee5c c\u00f3 ch\u1ee9a file \ncomponent.mk\n b\u00ean d\u01b0\u1edbi th\u01b0 m\u1ee5c \nCOMPONENT_DIRS\n\n\nEXTRA_COMPONENT_DIRS\n: M\u1eb7c \u0111\u1ecbnh kh\u00f4ng \u0111\u01b0\u1ee3c c\u1ea5u h\u00ecnh, s\u1eed d\u1ee5ng \u0111\u1ec3 th\u00eam th\u01b0 m\u1ee5c ch\u1ee9a component, c\u00f9ng v\u1edbi \nCOMPONENT_DIRS\n.\n\n\nSRCDIRS\n: Th\u01b0 m\u1ee5c b\u00ean d\u01b0\u1edbi th\u01b0 m\u1ee5c d\u1ef1 \u00e1n ch\u1ee9a m\u00e3 ngu\u1ed3n, m\u1eb7c \u0111\u1ecbnh l\u00e0 th\u01b0 m\u1ee5c \nmain\n \n\n\n\n\nC\u00e1c bi\u1ebfn c\u00f3 trong \ncomponent.mk\n c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c c\u1ea5u h\u00ecnh b\u1edfi l\u1eadp tr\u00ecnh vi\u00ean:\n\n\n\n\nCOMPONENT_ADD_INCLUDEDIRS\n: Relative path to include directories to be added to the entire project. If an include directory is only needed to compile this specific component, don\u2019t add it here.\n\n\nCOMPONENT_PRIV_INCLUDEDIRS\n: Relative path to include directories that are only used when compiling this specific component.\n\nCOMPONENT_DEPENDS\n: Names of any components that need to be compiled before this component.\n\n\nCOMPONENT_ADD_LDFLAGS\n: LD flags to add for the entire project. Defaults to -l$(COMPONENT_NAME). Add libraries etc in the current directory as $(abspath libwhatever.a)\n\n\nCOMPONENT_EXTRA_INCLUDES\n: Any extra include paths used when compiling the component\u2019s source files. These will be prefixed with \u2018-I\u2019 and passed to the compiler. Similar to COMPONENT_PRIV_INCLUDEDIRS, but these paths are passed as-is instead of expanded relative to the component directory.\n\n\nCOMPONENT_SRCDIRS\n: Relative directories to look in for sources. Defaults to \u2018.\u2019, the current directory (the root of the component) only. Use this to specify any subdirectories. Note that specifying this overwrites the default action of compiling everything in the components root dir; to keep this behaviour please also add \u2018.\u2019 as a directory in thislist.\n\n\nCOMPONENT_OBJS\n: Object files to compile. Defaults to the .o variants of all .c and .S files that are found in COMPONENT_SRCDIRS.\n\n\nCOMPONENT_EXTRA_CLEAN\n: Files that are generated using rules in the components Makefile that also need to be cleaned\n\n\nCOMPONENT_BUILDRECIPE\n: Recipe to build the component. Optional. Defaults to building all COMPONENT_OBJS and linking them into lib(componentname).a\n\n\nCOMPONENT_CLEANRECIPE\n: Recipe to clean the component. Optional. Defaults to removing all built objects and libraries.\n\n\nCOMPONENT_BUILD_DIR\n: Equals the cwd of the component build, which is the build dir of the component (where all the .o etc files should be created).\n\n\n\n\nThese variables are already set early on in the Makefile and the values in it will\nbe usable in component or project Makefiles::\n\n\nCC, LD, AR, OBJCOPY: Xtensa gcc tools\nHOSTCC, HOSTLD etc: Host gcc tools\nLDFLAGS, CFLAGS: Set to usable values as defined in ESP-IDF Makefile\nPROJECT_NAME: Name of the project, as set in project makefile\nPROJECT_PATH: Path to the root of the project folder\nCOMPONENTS: Name of the components to be included\nCONFIG_*: All values set by 'make menuconfig' have corresponding Makefile variables.\n\n\n\nInside your component\u2019s component.mk makefile, you can override or add to these variables\nas necessary. The changes are isolated from other components (see Makefile.projbuild below\nif you want to share these changes with all other components.)\n\n\nFor components, there also are these defines::\n\n\nCOMPONENT_PATH: Absolute path to the root of the source tree of the component we're\n    compiling\nCOMPONENT_LIBRARY: The full path to the static library the components compilation pass\n    is supposed to generate\n\n\n\nMake Process\n#\n\n\nThe Make process is always invoked from the project directory by the\nuser; invoking it anywhere else gives an error. This is what happens if\nwe build a binary:\n\n\nThe Makefile first determines how it was included. It figures out\nvarious paths as well as the components available to it. It will also\ncollect the ldflags and includes that the components specify they need.\nIt does this by running a dummy make on the components with a \u201cget_variable\u201d\ntarget that will output these values.\n\n\nThe Makefile will then create targets to build the lib*.a libraries of\nall components and make the elf target depend on this. The main Makefile\ninvokes Make on the componen.mk of each components inside a sub-mke: this way\nthe components have full freedom to do whatever is necessary to build\nthe library without influencing other components. By default, the\ncomponent.mk includes the utility makefile $(IDF_PATH)/make/component_common.mk.\nThis provides default targets and configurations that will work\nout-of-the-box for most projects.\n\n\nKConfig\n#\n\n\nEach component can also have a Kconfig file, alongside the component.mk, that contains\ndetails to add to \u201cmenuconfig\u201d for this component.\n\n\nMakefile.projbuild\n#\n\n\nFor components that have parts that need to be evaluated in the top-level\nproject context, you can create a file called Makefile.projbuild in the\ncomponent root directory. These files is included into the project\u2019s\ntop-level Makefile.\n\n\nFor example, if your component needs to add to CFLAGS for the entire\nproject (not just for its own source files) then you can set\n\nCFLAGS +=\n in Makefile.projbuild. Note that this isn\u2019t necessary for\nadding include directories to the project, you can set\n\nCOMPONENT_ADD_INCLUDEDIRS\n (see above) in the component.mk.\n\n\nKConfig.projbuild\n#\n\n\nThere\u2019s an equivalent to Makefile.projbuild for KConfig: if you want to include\noptions at the top-level, not inside the \u2018components\u2019 submenu then create a Kconfig.projbuild and\nit will be included in the main menu of menuconfig.\n\n\nTake good care when (re)defining stuff here: because it\u2019s included with all the other\n.projbuild files, it\u2019s possible to overwrite variables or re-declare targets defined in\nthe ESP-IDF makefile/Kconfig and other .projbuild files. It\u2019s generally better to just\ncreate a KConfig file, if you can.\n\n\nWriting Component Makefiles\n#\n\n\nA component consists of a directory which doubles as the name for the\ncomponent: a component named \u2018httpd\u2019 lives in a directory called \u2018httpd\u2019\nBecause components usually live under the project directory (although\nthey can also reside in an other folder), the path to this may be\nsomething like  /home/myuser/projects/myprojects/components/httpd .\n\n\nComponents can have any name (unique to the project) but the name\ncannot contain spaces (esp-idf does not support spaces in paths).\n\n\nOne of the things that most components will have is a component.mk makefile,\ncontaining instructions on how to build the component. Because the\nbuild environment tries to set reasonable defaults that will work most\nof the time, component.mk can be very small.\n\n\nSimplest component.mk\n#\n\n\nAt the  minimum, component.mk will just include the ESP-IDF component \u201ccommon\u201d makefile,\nwhich adds common component functionality::\n\n\ninclude $(IDF_PATH)/make/component_common.mk\n\n\n\nThis will take all the .c and .S files in the component root and compile\nthem into  object files, finally linking them into a library.\n\n\nAdding source directories\n#\n\n\nBy default, subdirectories are ignored. If your project has sources in subdirectories\ninstead of in the root of the component then you can tell that to the build\nsystem by setting COMPONENT_SRCDIRS::\n\n\nCOMPONENT_SRCDIRS := src1 src2\ninclude $(IDF_PATH)/make/component_common.mk\n\n\n\nThis will compile all source files in the src1/ and src2/ subdirectories\ninstead.\n\n\nSpecifying source files\n#\n\n\nThe standard component.mk logic adds all .S and .c files in the source\ndirectories as sources to be compiled unconditionally. It is possible\nto circumvent that logic and hardcode the objects to be compiled by\nmanually setting the COMPONENT_OBJS variable to the name of the\nobjects that need to be generated::\n\n\nCOMPONENT_OBJS := file1.o file2.o thing/filea.o thing/fileb.o anotherthing/main.o\ninclude $(IDF_PATH)/make/component_common.mk\n\n\n\nAdding conditional configuration\n#\n\n\nThe configuration system can be used to conditionally compile some files\ndependending on the options selected in \nmake menuconfig\n:\n\n\nKconfig::\n    config FOO_ENABLE_BAR\n        bool \u201cEnable the BAR feature.\u201d\n        help\n            This enables the BAR feature of the FOO component.\n\n\nMakefile::\n    COMPONENT_OBJS := foo_a.o foo_b.o $(if $(CONFIG_FOO_ENABLE_BAR),foo_bar.o foo_bar_interface.o)\n    include $(IDF_PATH)/make/component_common.mk\n\n\nSource Code Generation\n#\n\n\nSome components will have a situation where a source file isn\u2019t supplied\nwith the  component itself but has to be generated from another file. Say\nour component has a header file that consists of the converted binary\ndata of a BMP file, converted using a hypothetical tool called bmp2h. The\nheader file is then included in as C source file called graphics_lib.c::\n\n\nCOMPONENT_EXTRA_CLEAN := logo.h\n\ngraphics_lib.o: logo.h\n\nlogo.h: $(COMPONENT_PATH)/logo.bmp\n    bmp2h -i $^ -o $@\n\ninclude $(IDF_PATH)/make/component_common.mk\n\n\n\nIn this example, graphics_lib.o and logo.h will be generated in the\ncurrent directory (the build directory) while logo.bmp comes with the\ncomponent and resides under the component path. Because logo.h is a\ngenerated file, it needs to be cleaned when make clean is called which\nwhy it is added to the COMPONENT_EXTRA_CLEAN variable.\n\n\nCosmetic Improvements\n#\n\n\nThe above example will work just fine, but there\u2019s one last cosmetic\nimprovement that can be done. The make system tries to make the make\nprocess somewhat easier on the  eyes by hiding the commands (unless you\nrun make with the V=1 switch) and this does  not do that yet. Here\u2019s an\nimproved version that will output in the same style as  the rest of the\nmake process::\n\n\nCOMPONENT_EXTRA_CLEAN := test_tjpgd_logo.h\n\n\ngraphics_lib.o: logo.h\n\n\nlogo.h: $(COMPONENT_PATH)/logo.bmp\n    $(summary) BMP2H $@\n    $(Q) bmp2h -i $^ -o $@\n\ninclude $(IDF_PATH)/make/component_common.mk\n\n\n\nFully Overriding The Component Makefile\n#\n\n\nObviously, there are cases where all these recipes are insufficient for a\ncertain component, for example when the component is basically a wrapper\naround another third-party component not originally intended to be\ncompiled under this build system. In that case, it\u2019s possible to forego\nthe build  system entirely by setting COMPONENT_OWNBUILDTARGET and\npossibly  COMPONENT_OWNCLEANTARGET and defining your own build- and clean\ntarget. The build target can do anything as long as it creates\n$(COMPONENT_LIBRARY) for the main file to link into the project binary,\nand even that is not necessary: if the COMPONENT_ADD_LDFLAGS variable\nis set, the component can instruct the linker to do anything else as well.\n\n\n.. _esp-idf-template: https://github.com/espressif/esp-idf-template",
            "title": "H\u1ec7 th\u1ed1ng bi\u00ean d\u1ecbch"
        },
        {
            "location": "/esp-idf/basic/build-system/#he-thong-bien-dich-cho-esp-idf",
            "text": "N\u1ed9i dung t\u00e0i li\u1ec7u n\u00e0y gi\u1ea3i th\u00edch c\u00e1ch th\u1ee9c bi\u00ean d\u1ecbch cho Espressif IoT Development Framework v\u00e0 nguy\u00ean l\u00fd l\u00e0m vi\u1ec7c c\u1ee7a \u201ccomponents\u201d  \u0110\u1ecdc t\u00e0i li\u1ec7u n\u00e0y n\u1ebfu b\u1ea1n mu\u1ed1n bi\u1ebft l\u00e0m th\u1ebf n\u00e0o \u0111\u1ec3 t\u1ed5 ch\u1ee9c m\u1ed9t d\u1ef1 \u00e1n  ESP-IDF  m\u1edbi  B\u1ea1n n\u00ean xem qua d\u1ef1 \u00e1n m\u1eabu  esp-idf-template  \u0111\u1ec3 c\u00f3 c\u00e1i nh\u00ecn kh\u1edfi \u0111\u1ea7u t\u1ed1t h\u01a1n.",
            "title": "H\u1ec7 th\u1ed1ng bi\u00ean d\u1ecbch cho ESP-IDF"
        },
        {
            "location": "/esp-idf/basic/build-system/#tong-quan",
            "text": "M\u1ed9t d\u1ef1 \u00e1n  ESP-IDF  c\u00f3 th\u1ec3 h\u1ed7n h\u1ee3p nhi\u1ec1u \u201ccomponents\u201d. V\u00ed d\u1ee5: v\u1edbi 1 Web Server hi\u1ec3n th\u1ecb \u0111\u1ed9 \u1ea9m hi\u1ec7n t\u1ea1i, ch\u00fang ta c\u1ea7n:    Th\u01b0 vi\u1ec7n c\u01a1 b\u1ea3n cho ESP32 (libc, rom bindings v.v..)  WiFi drivers  TCP/IP stack  H\u1ec7 \u0111i\u1ec1u h\u00e0nh FreeRTOS  M\u1ed9t webserver  M\u1ed9t driver cho c\u1ea3m bi\u1ebfn \u0111\u1ed9 \u1ea9m  Ch\u01b0\u01a1ng tr\u00ecnh ch\u00ednh \u0111\u1ec3 gh\u00e9p n\u1ed1i t\u1ea5t c\u1ea3   ESP-IDF  l\u00e0m cho c\u00e1c \u201ccomponent\u201d r\u00f5 r\u00e0ng v\u00e0 d\u1ec5 d\u00e0ng c\u1ea5u h\u00ecnh. \u0110\u1ec3 l\u00e0m \u0111\u01b0\u1ee3c \u0111i\u1ec1u \u0111\u00f3, khi m\u1ed9t d\u1ef1 \u00e1n \u0111\u01b0\u1ee3c bi\u00ean so\u1ea1n, m\u00f4i tr\u01b0\u1eddng bi\u00ean d\u1ecbch s\u1ebd t\u00ecm t\u1ea5t c\u1ea3 c\u00e1c th\u00e0nh ph\u1ea7n trong th\u01b0 m\u1ee5c  ESP-IDF , c\u00e1c th\u01b0 m\u1ee5c d\u1ef1 \u00e1n v\u00e0 th\u00f4ng tin c\u1ea5u h\u00ecnh c\u1ee7a m\u1ed7i component. N\u00f3 cho ph\u00e9p ng\u01b0\u1eddi s\u1eed d\u1ee5ng c\u00f3 th\u1ec3 c\u1ea5u h\u00ecnh m\u1ed7i l\u1ea7n bi\u00ean d\u1ecbch s\u1eed d\u1ee5ng h\u1ec7 th\u1ed1ng menu d\u1ef1a tr\u00ean v\u0103n b\u1ea3n th\u00e2n thi\u1ec7n \u0111\u1ec3 t\u00f9y ch\u1ec9nh ESP-IDF c\u0169ng nh\u01b0 c\u00e1c th\u00e0nh ph\u1ea7n kh\u00e1c \u0111\u01b0\u1ee3c y\u00eau c\u1ea7u b\u1edfi d\u1ef1 \u00e1n. Sau khi c\u00e1c component \u0111\u01b0\u1ee3c t\u00f9y bi\u1ebfn, ti\u1ebfn tr\u00ecnh bi\u00ean d\u1ecbch s\u1ebd bi\u00ean d\u1ecbch t\u1ea5t c\u1ea3 m\u1ecdi th\u1ee9 v\u00e0o m\u1ed9t t\u1eadp tin cu\u1ed1i c\u00f9ng, \u0111\u1ec3 c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c n\u1ea1p v\u00e0o b\u1ea3ng m\u1ea1ch ESP32.  M\u1ed9t d\u1ef1 \u00e1n nh\u01b0 \u0111\u00e3 n\u00f3i tr\u00ean \u0111\u01b0\u1ee3c \u0111\u1ecbnh ngh\u0129a nh\u01b0 l\u00e0 m\u1ed9t th\u01b0 m\u1ee5c, theo \u0111\u00f3 y\u00eau c\u1ea7u t\u1ea5t c\u1ea3 c\u00e1c t\u1eadp tin nh\u01b0 h\u1ec7 th\u1ed1ng th\u01b0 m\u1ee5c b\u00ean d\u01b0\u1edbi kh\u00f4ng bao g\u1ed3m c\u00e1c t\u1eadp tin c\u1ee7a ESP-IDF v\u00e0 toolchain. M\u1ed9t d\u1ef1 \u00e1n \u0111\u01a1n gi\u1ea3n tr\u00f4ng nh\u01b0 sau:  myProject/\n  |--build/\n  |--components/ \n  |   |-- component1/ \n  |   |     |-- component.mk\n  |   |     |-- Kconfig\n  |   |     |-- src1.c\n  |   |-- component2/ \n  |   |     |-- component.mk\n  |   |     |-- Kconfig\n  |   |     |-- src1.c\n  |-- main/       \n      |-- src1.c\n      |-- src2.c\n      `-- Makefile  Nh\u01b0 \u0111\u00e3 th\u1ea5y, m\u1ed9t d\u1ef1 \u00e1n c\u00f3 m\u1ed9t th\u01b0 m\u1ee5c con  components/  bao g\u1ed3m c\u00e1c  components  ch\u1ee9a \u0111\u1ef1ng trong 1 ho\u1eb7c nhi\u1ec1u th\u01b0 m\u1ee5c v\u00e0 c\u00e1c t\u1eadp tin m\u00e3 ngu\u1ed3n cho d\u1ef1 \u00e1n, m\u1eb7c \u0111\u1ecbnh, l\u00e0 th\u01b0 m\u1ee5c  main . D\u1ef1 \u00e1n c\u0169ng c\u00f3 c\u1ea3  Makefile , ch\u1ee9a th\u00f4ng tin t\u00ean d\u1ef1 \u00e1n c\u0169ng nh\u01b0 c\u00e1c t\u00f9y ch\u1ecdn bi\u00ean d\u1ecbch. Sau khi bi\u00ean d\u1ecbch, d\u1ef1 \u00e1n s\u1ebd bao g\u1ed3m th\u01b0 m\u1ee5c  build  bao g\u1ed3m t\u1ea5t c\u1ea3 c\u00e1c object, th\u01b0 vi\u1ec7n \u0111\u01b0\u1ee3c bi\u00ean d\u1ecbch ra, bao g\u1ed3m c\u1ea3 file binary th\u00e0nh ph\u1ea9m cu\u1ed1i c\u00f9ng.  M\u1ed7i component s\u1ebd c\u00f3 1  Makefile  g\u1ecdi l\u00e0  component.mk  ch\u1ee9a \u0111\u1ef1ng m\u1ed9t s\u1ed1 \u0111\u1ecbnh ngh\u0129a bi\u00ean d\u1ecbch cho component \u0111\u00f3, bao g\u1ed3m ti\u1ebfn tr\u00ecnh bi\u00ean d\u1ecbch. Component c\u0169ng c\u00f3 th\u1ec3 bao g\u1ed3m  Kconfig  file, \u0111\u1ecbnh ngh\u0129a nh\u1eefng t\u00f9y ch\u1ecdn cho m\u1ed7i l\u1ea7n bi\u00ean d\u1ecbch, c\u00f3 th\u1ebb c\u1ea5u h\u00ecnh v\u1edbi h\u1ec7 th\u1ed1ng Menu ( make menuconfig )  C\u00e1c bi\u1ebfn ch\u1ee9a trong  Makefile  cho d\u1ef1 \u00e1n c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c set b\u1edfi l\u1eadp tr\u00ecnh vi\u00ean:   PROJECT_NAME : B\u1eaft bu\u1ed9c. T\u00ean c\u1ee7a d\u1ef1 \u00e1n  BUILD_DIR_BASE : Th\u01b0 m\u1ee5c ch\u1ee9a t\u1ea5t c\u1ea3 c\u00e1c object, th\u01b0 vi\u1ec7n, binary \u0111\u01b0\u1ee3c bi\u00ean d\u1ecbch ra. M\u1eb7c \u0111\u1ecbnh  $(PROJECT_PATH)/build  COMPONENT_DIRS : Th\u01b0 m\u1ee5c h\u1ec7 th\u1ed1ng bien d\u1ecbch s\u1ebd t\u00ecm ki\u1ebfm c\u00e1c component. M\u1eb7c \u0111\u1ecbnh  component/  trong d\u1ef1 \u00e1n ESP-IDF  COMPONENTS : Danh s\u00e1ch c\u00e1c t\u00ean component s\u1ebd bi\u00ean d\u1ecbch, m\u1eb7c \u0111\u1ecbnh l\u00e0 t\u1ea5t c\u1ea3 c\u00e1c th\u01b0 m\u1ee5c c\u00f3 ch\u1ee9a file  component.mk  b\u00ean d\u01b0\u1edbi th\u01b0 m\u1ee5c  COMPONENT_DIRS  EXTRA_COMPONENT_DIRS : M\u1eb7c \u0111\u1ecbnh kh\u00f4ng \u0111\u01b0\u1ee3c c\u1ea5u h\u00ecnh, s\u1eed d\u1ee5ng \u0111\u1ec3 th\u00eam th\u01b0 m\u1ee5c ch\u1ee9a component, c\u00f9ng v\u1edbi  COMPONENT_DIRS .  SRCDIRS : Th\u01b0 m\u1ee5c b\u00ean d\u01b0\u1edbi th\u01b0 m\u1ee5c d\u1ef1 \u00e1n ch\u1ee9a m\u00e3 ngu\u1ed3n, m\u1eb7c \u0111\u1ecbnh l\u00e0 th\u01b0 m\u1ee5c  main     C\u00e1c bi\u1ebfn c\u00f3 trong  component.mk  c\u00f3 th\u1ec3 \u0111\u01b0\u1ee3c c\u1ea5u h\u00ecnh b\u1edfi l\u1eadp tr\u00ecnh vi\u00ean:   COMPONENT_ADD_INCLUDEDIRS : Relative path to include directories to be added to the entire project. If an include directory is only needed to compile this specific component, don\u2019t add it here.  COMPONENT_PRIV_INCLUDEDIRS : Relative path to include directories that are only used when compiling this specific component. COMPONENT_DEPENDS : Names of any components that need to be compiled before this component.  COMPONENT_ADD_LDFLAGS : LD flags to add for the entire project. Defaults to -l$(COMPONENT_NAME). Add libraries etc in the current directory as $(abspath libwhatever.a)  COMPONENT_EXTRA_INCLUDES : Any extra include paths used when compiling the component\u2019s source files. These will be prefixed with \u2018-I\u2019 and passed to the compiler. Similar to COMPONENT_PRIV_INCLUDEDIRS, but these paths are passed as-is instead of expanded relative to the component directory.  COMPONENT_SRCDIRS : Relative directories to look in for sources. Defaults to \u2018.\u2019, the current directory (the root of the component) only. Use this to specify any subdirectories. Note that specifying this overwrites the default action of compiling everything in the components root dir; to keep this behaviour please also add \u2018.\u2019 as a directory in thislist.  COMPONENT_OBJS : Object files to compile. Defaults to the .o variants of all .c and .S files that are found in COMPONENT_SRCDIRS.  COMPONENT_EXTRA_CLEAN : Files that are generated using rules in the components Makefile that also need to be cleaned  COMPONENT_BUILDRECIPE : Recipe to build the component. Optional. Defaults to building all COMPONENT_OBJS and linking them into lib(componentname).a  COMPONENT_CLEANRECIPE : Recipe to clean the component. Optional. Defaults to removing all built objects and libraries.  COMPONENT_BUILD_DIR : Equals the cwd of the component build, which is the build dir of the component (where all the .o etc files should be created).   These variables are already set early on in the Makefile and the values in it will\nbe usable in component or project Makefiles::  CC, LD, AR, OBJCOPY: Xtensa gcc tools\nHOSTCC, HOSTLD etc: Host gcc tools\nLDFLAGS, CFLAGS: Set to usable values as defined in ESP-IDF Makefile\nPROJECT_NAME: Name of the project, as set in project makefile\nPROJECT_PATH: Path to the root of the project folder\nCOMPONENTS: Name of the components to be included\nCONFIG_*: All values set by 'make menuconfig' have corresponding Makefile variables.  Inside your component\u2019s component.mk makefile, you can override or add to these variables\nas necessary. The changes are isolated from other components (see Makefile.projbuild below\nif you want to share these changes with all other components.)  For components, there also are these defines::  COMPONENT_PATH: Absolute path to the root of the source tree of the component we're\n    compiling\nCOMPONENT_LIBRARY: The full path to the static library the components compilation pass\n    is supposed to generate",
            "title": "T\u1ed5ng quan"
        },
        {
            "location": "/esp-idf/basic/build-system/#make-process",
            "text": "The Make process is always invoked from the project directory by the\nuser; invoking it anywhere else gives an error. This is what happens if\nwe build a binary:  The Makefile first determines how it was included. It figures out\nvarious paths as well as the components available to it. It will also\ncollect the ldflags and includes that the components specify they need.\nIt does this by running a dummy make on the components with a \u201cget_variable\u201d\ntarget that will output these values.  The Makefile will then create targets to build the lib*.a libraries of\nall components and make the elf target depend on this. The main Makefile\ninvokes Make on the componen.mk of each components inside a sub-mke: this way\nthe components have full freedom to do whatever is necessary to build\nthe library without influencing other components. By default, the\ncomponent.mk includes the utility makefile $(IDF_PATH)/make/component_common.mk.\nThis provides default targets and configurations that will work\nout-of-the-box for most projects.",
            "title": "Make Process"
        },
        {
            "location": "/esp-idf/basic/build-system/#kconfig",
            "text": "Each component can also have a Kconfig file, alongside the component.mk, that contains\ndetails to add to \u201cmenuconfig\u201d for this component.",
            "title": "KConfig"
        },
        {
            "location": "/esp-idf/basic/build-system/#makefileprojbuild",
            "text": "For components that have parts that need to be evaluated in the top-level\nproject context, you can create a file called Makefile.projbuild in the\ncomponent root directory. These files is included into the project\u2019s\ntop-level Makefile.  For example, if your component needs to add to CFLAGS for the entire\nproject (not just for its own source files) then you can set CFLAGS +=  in Makefile.projbuild. Note that this isn\u2019t necessary for\nadding include directories to the project, you can set COMPONENT_ADD_INCLUDEDIRS  (see above) in the component.mk.",
            "title": "Makefile.projbuild"
        },
        {
            "location": "/esp-idf/basic/build-system/#kconfigprojbuild",
            "text": "There\u2019s an equivalent to Makefile.projbuild for KConfig: if you want to include\noptions at the top-level, not inside the \u2018components\u2019 submenu then create a Kconfig.projbuild and\nit will be included in the main menu of menuconfig.  Take good care when (re)defining stuff here: because it\u2019s included with all the other\n.projbuild files, it\u2019s possible to overwrite variables or re-declare targets defined in\nthe ESP-IDF makefile/Kconfig and other .projbuild files. It\u2019s generally better to just\ncreate a KConfig file, if you can.",
            "title": "KConfig.projbuild"
        },
        {
            "location": "/esp-idf/basic/build-system/#writing-component-makefiles",
            "text": "A component consists of a directory which doubles as the name for the\ncomponent: a component named \u2018httpd\u2019 lives in a directory called \u2018httpd\u2019\nBecause components usually live under the project directory (although\nthey can also reside in an other folder), the path to this may be\nsomething like  /home/myuser/projects/myprojects/components/httpd .  Components can have any name (unique to the project) but the name\ncannot contain spaces (esp-idf does not support spaces in paths).  One of the things that most components will have is a component.mk makefile,\ncontaining instructions on how to build the component. Because the\nbuild environment tries to set reasonable defaults that will work most\nof the time, component.mk can be very small.",
            "title": "Writing Component Makefiles"
        },
        {
            "location": "/esp-idf/basic/build-system/#simplest-componentmk",
            "text": "At the  minimum, component.mk will just include the ESP-IDF component \u201ccommon\u201d makefile,\nwhich adds common component functionality::  include $(IDF_PATH)/make/component_common.mk  This will take all the .c and .S files in the component root and compile\nthem into  object files, finally linking them into a library.",
            "title": "Simplest component.mk"
        },
        {
            "location": "/esp-idf/basic/build-system/#adding-source-directories",
            "text": "By default, subdirectories are ignored. If your project has sources in subdirectories\ninstead of in the root of the component then you can tell that to the build\nsystem by setting COMPONENT_SRCDIRS::  COMPONENT_SRCDIRS := src1 src2\ninclude $(IDF_PATH)/make/component_common.mk  This will compile all source files in the src1/ and src2/ subdirectories\ninstead.",
            "title": "Adding source directories"
        },
        {
            "location": "/esp-idf/basic/build-system/#specifying-source-files",
            "text": "The standard component.mk logic adds all .S and .c files in the source\ndirectories as sources to be compiled unconditionally. It is possible\nto circumvent that logic and hardcode the objects to be compiled by\nmanually setting the COMPONENT_OBJS variable to the name of the\nobjects that need to be generated::  COMPONENT_OBJS := file1.o file2.o thing/filea.o thing/fileb.o anotherthing/main.o\ninclude $(IDF_PATH)/make/component_common.mk",
            "title": "Specifying source files"
        },
        {
            "location": "/esp-idf/basic/build-system/#adding-conditional-configuration",
            "text": "The configuration system can be used to conditionally compile some files\ndependending on the options selected in  make menuconfig :  Kconfig::\n    config FOO_ENABLE_BAR\n        bool \u201cEnable the BAR feature.\u201d\n        help\n            This enables the BAR feature of the FOO component.  Makefile::\n    COMPONENT_OBJS := foo_a.o foo_b.o $(if $(CONFIG_FOO_ENABLE_BAR),foo_bar.o foo_bar_interface.o)\n    include $(IDF_PATH)/make/component_common.mk",
            "title": "Adding conditional configuration"
        },
        {
            "location": "/esp-idf/basic/build-system/#source-code-generation",
            "text": "Some components will have a situation where a source file isn\u2019t supplied\nwith the  component itself but has to be generated from another file. Say\nour component has a header file that consists of the converted binary\ndata of a BMP file, converted using a hypothetical tool called bmp2h. The\nheader file is then included in as C source file called graphics_lib.c::  COMPONENT_EXTRA_CLEAN := logo.h\n\ngraphics_lib.o: logo.h\n\nlogo.h: $(COMPONENT_PATH)/logo.bmp\n    bmp2h -i $^ -o $@\n\ninclude $(IDF_PATH)/make/component_common.mk  In this example, graphics_lib.o and logo.h will be generated in the\ncurrent directory (the build directory) while logo.bmp comes with the\ncomponent and resides under the component path. Because logo.h is a\ngenerated file, it needs to be cleaned when make clean is called which\nwhy it is added to the COMPONENT_EXTRA_CLEAN variable.",
            "title": "Source Code Generation"
        },
        {
            "location": "/esp-idf/basic/build-system/#cosmetic-improvements",
            "text": "The above example will work just fine, but there\u2019s one last cosmetic\nimprovement that can be done. The make system tries to make the make\nprocess somewhat easier on the  eyes by hiding the commands (unless you\nrun make with the V=1 switch) and this does  not do that yet. Here\u2019s an\nimproved version that will output in the same style as  the rest of the\nmake process::  COMPONENT_EXTRA_CLEAN := test_tjpgd_logo.h  graphics_lib.o: logo.h  logo.h: $(COMPONENT_PATH)/logo.bmp\n    $(summary) BMP2H $@\n    $(Q) bmp2h -i $^ -o $@\n\ninclude $(IDF_PATH)/make/component_common.mk",
            "title": "Cosmetic Improvements"
        },
        {
            "location": "/esp-idf/basic/build-system/#fully-overriding-the-component-makefile",
            "text": "Obviously, there are cases where all these recipes are insufficient for a\ncertain component, for example when the component is basically a wrapper\naround another third-party component not originally intended to be\ncompiled under this build system. In that case, it\u2019s possible to forego\nthe build  system entirely by setting COMPONENT_OWNBUILDTARGET and\npossibly  COMPONENT_OWNCLEANTARGET and defining your own build- and clean\ntarget. The build target can do anything as long as it creates\n$(COMPONENT_LIBRARY) for the main file to link into the project binary,\nand even that is not necessary: if the COMPONENT_ADD_LDFLAGS variable\nis set, the component can instruct the linker to do anything else as well.  .. _esp-idf-template: https://github.com/espressif/esp-idf-template",
            "title": "Fully Overriding The Component Makefile"
        },
        {
            "location": "/esp-idf/basic/install-windows/",
            "text": "Step 1: Toolchain for Windows: Quick Steps\n#\n\n\nWindows doesn\u2019t have a built-in \u201cmake\u201d environment, so as well as installing the toolchain you will need a GNU-compatible environment. We use the MSYS2_ environment to provide.\n You don\u2019t need to use this environment all the time (you can use Eclipse_ or some other front-end), but it runs behind the scenes.\n\n\nThe quick setup is to download the Windows all-in-one toolchain & MSYS zip file from dl.espressif.com:\n\n\nhttps://dl.espressif.com/dl/esp32_win32_msys2_environment_and_toolchain-20160816.zip\n\n\nUnzip the zip file to C:\\ and it will create an \u201cmsys32\u201d directory with a pre-prepared environment.\n\n\nAlternative Step 1: Configure toolchain & environment from scratch\n#\n\n\nAs an alternative to getting a pre-prepared environment, you can set up the environment from scratch:\n\n\n\n\n\n\nNavigate to the MSYS2_ installer page and download the \nmsys2-i686-xxxxxxx.exe\n installer executable (we only support a 32-bit MSYS environment, it works on both 32-bit and 64-bit Windows.)\n\n\n\n\n\n\nRun through the installer steps, and accept the \u201cRun MSYS2 now\u201d option at the end. A window will open with a MSYS2 terminal.\n\n\n\n\n\n\nThe ESP-IDF repository on github contains a script in the tools directory titled \nwindows_install_prerequisites.sh\n. If you haven\u2019t downloaded the ESP-IDF yet, that\u2019s OK - you can just \ndownload that one file in Raw format from here <https://github.com/espressif/esp-idf/raw/master/tools/windows/windows_install_prerequisites.sh>\n_. Save it somewhere on your computer.\n\n\n\n\n\n\nType the path to the shell script into the MSYS2 terminal window. You can type it as a normal Windows path, but use forward-slashes instead of back-slashes. ie: \nC:/Users/myuser/Downloads/windows_install_prerequisites.sh\n. You can read the script beforehand to check what it does.\n\n\n\n\n\n\nIf you use the 201602 MSYS2 installer, the first time you run \nwindows_install_prerequisites.sh\n it will update the MSYS2 core system. At the end of this update, you will be prompted to close the MSYS2 terminal and re-open. When you re-open after the update, re-run \nwindows_install_prerequisites.sh\n. The next version of MSYS2 (after 201602) will not need this interim step.\n\n\n\n\n\n\nThe \nwindows_install_prerequisites.sh\n script will download and install packages for ESP-IDF support, and the ESP32 toolchain.\n\n\n\n\n\n\nNote: You may encounter a bug where svchost.exe uses 100% CPU in Windows after setup is finished, resulting in the ESP-IDF building very slowly. Terminating svchost.exe or restarting Windows will solve this problem.\n\n\nAnother Alternative Step 1: Just download a toolchain\n#\n\n\nIf you already have an MSYS2 install or want to do things differently, you can download just the toolchain here:\n\n\nhttps://dl.espressif.com/dl/xtensa-esp32-elf-win32-1.22.0-59.zip\n\n\nIf you followed one of the above options for Step 1, you won\u2019t need this download.\n\n\nImportant: Just having this toolchain is \nnot enough\n to use ESP-IDF on Windows. You will need GNU make, bash, and sed at minimum. The above environments provide all this, plus a host compiler (required for menuconfig support).\n\n\nStep 2: Getting the esp-idf repository from github\n#\n\n\nOpen an MSYS2 terminal window by running \nC:\\msys32\\msys2_shell.cmd\n. The environment in this window is a bash shell.\n\n\nChange to the directory you want to clone the SDK into by typing a command like this one: \ncd \"C:/path/to/dir\"\n (note the forward-slashes in the path). Then type \ngit clone --recursive https://github.com/espressif/esp-idf.git\n\n\nIf you\u2019d rather use a Windows UI tool to manage your git repositories, this is also possible. A wide range are available.\n\n\nNOTE\n: While cloning submodules, the \ngit clone\n command may print some output starting \n': not a valid identifier...\n. This is a \nknown issue\n_ but the git clone still succeeds without any problems.\n\n\nStep 3: Starting a project\n#\n\n\nESP-IDF by itself does not build a binary to run on the ESP32. The binary \u201capp\u201d comes from a project in a different directory. Multiple projects can share the same ESP-IDF directory on your computer.\n\n\nThe easiest way to start a project is to download the Getting Started project from github_.\n\n\nThe process is the same as for checking out the ESP-IDF from github. Change to the parent directory and run \ngit clone https://github.com/espressif/esp-idf-template.git\n.\n\n\nIMPORTANT:\n The esp-idf build system does not support spaces in paths to esp-idf or to projects.\n\n\nStep 4: Configuring the project\n#\n\n\nOpen an MSYS2 terminal window by running \nC:\\msys32\\msys2_shell.cmd\n. The environment in this window is a bash shell.\n\n\nType a command like this to set the path to ESP-IDF directory: \nexport IDF_PATH=\"C:/path/to/esp-idf\"\n (note the forward-slashes not back-slashes for the path). If you don\u2019t want to run this command every time you open an MSYS2 window, create a new file in \nC:/msys32/etc/profile.d/\n and paste this line in - then it will be run each time you open an MYS2 terminal.\n\n\nUse \ncd\n to change to the project directory (not the ESP-IDF directory.) Type \nmake menuconfig\n to configure your project, then \nmake\n to build it, \nmake clean\n to remove built files, and \nmake flash\n to flash (use the menuconfig to set the serial port for flashing.)\n\n\nIf you\u2019d like to use the Eclipse IDE instead of running \nmake\n, check out the Eclipse setup guide in this directory.\n\n\n.. _Eclipse: eclipse-setup.rst\n.. _MSYS2: https://msys2.github.io/\n.. _github: https://github.com/espressif/esp-idf-template\n.. _known issue: https://github.com/espressif/esp-idf/issues/11",
            "title": "C\u00e0i \u0111\u1eb7t cho Windows"
        },
        {
            "location": "/esp-idf/basic/install-windows/#step-1-toolchain-for-windows-quick-steps",
            "text": "Windows doesn\u2019t have a built-in \u201cmake\u201d environment, so as well as installing the toolchain you will need a GNU-compatible environment. We use the MSYS2_ environment to provide.\n You don\u2019t need to use this environment all the time (you can use Eclipse_ or some other front-end), but it runs behind the scenes.  The quick setup is to download the Windows all-in-one toolchain & MSYS zip file from dl.espressif.com:  https://dl.espressif.com/dl/esp32_win32_msys2_environment_and_toolchain-20160816.zip  Unzip the zip file to C:\\ and it will create an \u201cmsys32\u201d directory with a pre-prepared environment.",
            "title": "Step 1: Toolchain for Windows: Quick Steps"
        },
        {
            "location": "/esp-idf/basic/install-windows/#alternative-step-1-configure-toolchain-environment-from-scratch",
            "text": "As an alternative to getting a pre-prepared environment, you can set up the environment from scratch:    Navigate to the MSYS2_ installer page and download the  msys2-i686-xxxxxxx.exe  installer executable (we only support a 32-bit MSYS environment, it works on both 32-bit and 64-bit Windows.)    Run through the installer steps, and accept the \u201cRun MSYS2 now\u201d option at the end. A window will open with a MSYS2 terminal.    The ESP-IDF repository on github contains a script in the tools directory titled  windows_install_prerequisites.sh . If you haven\u2019t downloaded the ESP-IDF yet, that\u2019s OK - you can just  download that one file in Raw format from here <https://github.com/espressif/esp-idf/raw/master/tools/windows/windows_install_prerequisites.sh> _. Save it somewhere on your computer.    Type the path to the shell script into the MSYS2 terminal window. You can type it as a normal Windows path, but use forward-slashes instead of back-slashes. ie:  C:/Users/myuser/Downloads/windows_install_prerequisites.sh . You can read the script beforehand to check what it does.    If you use the 201602 MSYS2 installer, the first time you run  windows_install_prerequisites.sh  it will update the MSYS2 core system. At the end of this update, you will be prompted to close the MSYS2 terminal and re-open. When you re-open after the update, re-run  windows_install_prerequisites.sh . The next version of MSYS2 (after 201602) will not need this interim step.    The  windows_install_prerequisites.sh  script will download and install packages for ESP-IDF support, and the ESP32 toolchain.    Note: You may encounter a bug where svchost.exe uses 100% CPU in Windows after setup is finished, resulting in the ESP-IDF building very slowly. Terminating svchost.exe or restarting Windows will solve this problem.",
            "title": "Alternative Step 1: Configure toolchain &amp; environment from scratch"
        },
        {
            "location": "/esp-idf/basic/install-windows/#another-alternative-step-1-just-download-a-toolchain",
            "text": "If you already have an MSYS2 install or want to do things differently, you can download just the toolchain here:  https://dl.espressif.com/dl/xtensa-esp32-elf-win32-1.22.0-59.zip  If you followed one of the above options for Step 1, you won\u2019t need this download.  Important: Just having this toolchain is  not enough  to use ESP-IDF on Windows. You will need GNU make, bash, and sed at minimum. The above environments provide all this, plus a host compiler (required for menuconfig support).",
            "title": "Another Alternative Step 1: Just download a toolchain"
        },
        {
            "location": "/esp-idf/basic/install-windows/#step-2-getting-the-esp-idf-repository-from-github",
            "text": "Open an MSYS2 terminal window by running  C:\\msys32\\msys2_shell.cmd . The environment in this window is a bash shell.  Change to the directory you want to clone the SDK into by typing a command like this one:  cd \"C:/path/to/dir\"  (note the forward-slashes in the path). Then type  git clone --recursive https://github.com/espressif/esp-idf.git  If you\u2019d rather use a Windows UI tool to manage your git repositories, this is also possible. A wide range are available.  NOTE : While cloning submodules, the  git clone  command may print some output starting  ': not a valid identifier... . This is a  known issue _ but the git clone still succeeds without any problems.",
            "title": "Step 2: Getting the esp-idf repository from github"
        },
        {
            "location": "/esp-idf/basic/install-windows/#step-3-starting-a-project",
            "text": "ESP-IDF by itself does not build a binary to run on the ESP32. The binary \u201capp\u201d comes from a project in a different directory. Multiple projects can share the same ESP-IDF directory on your computer.  The easiest way to start a project is to download the Getting Started project from github_.  The process is the same as for checking out the ESP-IDF from github. Change to the parent directory and run  git clone https://github.com/espressif/esp-idf-template.git .  IMPORTANT:  The esp-idf build system does not support spaces in paths to esp-idf or to projects.",
            "title": "Step 3: Starting a project"
        },
        {
            "location": "/esp-idf/basic/install-windows/#step-4-configuring-the-project",
            "text": "Open an MSYS2 terminal window by running  C:\\msys32\\msys2_shell.cmd . The environment in this window is a bash shell.  Type a command like this to set the path to ESP-IDF directory:  export IDF_PATH=\"C:/path/to/esp-idf\"  (note the forward-slashes not back-slashes for the path). If you don\u2019t want to run this command every time you open an MSYS2 window, create a new file in  C:/msys32/etc/profile.d/  and paste this line in - then it will be run each time you open an MYS2 terminal.  Use  cd  to change to the project directory (not the ESP-IDF directory.) Type  make menuconfig  to configure your project, then  make  to build it,  make clean  to remove built files, and  make flash  to flash (use the menuconfig to set the serial port for flashing.)  If you\u2019d like to use the Eclipse IDE instead of running  make , check out the Eclipse setup guide in this directory.  .. _Eclipse: eclipse-setup.rst\n.. _MSYS2: https://msys2.github.io/\n.. _github: https://github.com/espressif/esp-idf-template\n.. _known issue: https://github.com/espressif/esp-idf/issues/11",
            "title": "Step 4: Configuring the project"
        },
        {
            "location": "/esp-idf/basic/install-macos/",
            "text": "Step 0: Prerequisites\n#\n\n\nGetting MacPorts or homebrew\n#\n\n\nWhether you compile the toolchain from source or download binary toolchain, there are some dependencies which need to be installed on macOS first. These dependencies are installed with one of the package managers: homebrew or MacPorts. If you have these already, you can skip the following instructions.\n\n\n\n\nInstall XCode from Mac App Store\n\n\nOpen Terminal.app and run \nxcode-select --install\n\n\nRun \nsudo xcodebuild -license\n and agree to XCode license\n\n\nInstall MacPorts_ or homebrew_\n\n\n\n\n.. _homebrew: http://brew.sh/\n.. _MacPorts: https://www.macports.org/install.php\n\n\nStep 1: Download binary toolchain for the ESP32\n#\n\n\nESP32 toolchain for macOS is available for download from Espressif website:\n\n\nhttps://dl.espressif.com/dl/xtensa-esp32-elf-osx-1.22.0-59.tar.gz\n\n\nDownload this file, then extract it to the location you prefer, for example::\n\n\nmkdir -p ~/esp\ncd ~/esp\ntar -xzf ~/Downloads/xtensa-esp32-elf-osx-1.22.0-59.tar.gz\n\n\n\nThe toolchain will be extracted into \n~/esp/xtensa-esp32-elf/\n directory.\n\n\nTo use it, you will need to update your \nPATH\n environment variable in \n~/.profile\n file. To make \nxtensa-esp32-elf\n available for all terminal sessions, add the following line to your \n~/.profile\n file::\n\n\nexport PATH=$PATH:$HOME/esp/xtensa-esp32-elf/bin\n\n\n\nAlternatively, you may create an alias for the above command. This way you can get the toolchain only when you need it. To do this, add different line to your \n~/.profile\n file::\n\n\nalias get_esp32=\"export PATH=$PATH:$HOME/esp/xtensa-esp32-elf/bin\"\n\n\n\nThen when you need the toolchain you can type \nget_esp32\n on the command line and the toolchain will be added to your \nPATH\n.\n\n\nAlternative Step 1: Compile the toolchain from source using crosstool-NG\n#\n\n\nInstead of downloading binary toolchain from Espressif website (Step 1 above) you may build the toolchain yourself. \n\n\nIf you can\u2019t think of a reason why you need to build it yourself, then probably it\u2019s better to stick with the binary version. However, here are some of the reasons why you might want to compile it from source:\n\n\n\n\n\n\nif you want to customize toolchain build configuration\n\n\n\n\n\n\nif you want to hack gcc or newlib or libstdc++\n\n\n\n\n\n\nif you are curious and/or have time to spare\n\n\n\n\n\n\nif you don\u2019t trust binaries downloaded from the Internet\n\n\n\n\n\n\nIn any case, here are the steps to compile the toolchain yourself.\n\n\n\n\n\n\nInstall dependencies:\n\n\n\n\n\n\nwith MacPorts::\n\n\nsudo port install gsed gawk binutils gperf grep gettext ncurses\n\n\n\n\n\n\n\nwith homebrew (\nTODO: provide list of packages for homebrew\n)\n\n\n\n\n\n\nCreate a case-sensitive filesystem image::\n\n\nhdiutil create ~/esp/crosstool.dmg -volname \"ctng\" -size 10g -fs \"Case-sensitive HFS+\"\n\n\n\nMount it::\n\n\nhdiutil mount ~/esp/crosstool.dmg\n\n\n\nCreate a symlink to your work directory::\n\n\ncd ~/esp\nln -s /Volumes/ctng crosstool-NG\n\n\n\nDownload \ncrosstool-NG\n and build it::\n\n\ncd ~/esp\ngit clone -b xtensa-1.22.x https://github.com/espressif/crosstool-NG.git\ncd crosstool-NG\n./bootstrap && ./configure --prefix=$PWD && make install\n\n\n\nBuild the toolchain::\n\n\n./ct-ng xtensa-esp32-elf\n./ct-ng build\nchmod -R u+w builds/xtensa-esp32-elf\n\n\n\nToolchain will be built in \n~/esp/crosstool-NG/builds/xtensa-esp32-elf\n. Follow instructions given in the previous section to add the toolchain to your \nPATH\n.\n\n\nStep 2: Getting ESP-IDF from github\n#\n\n\nOpen Terminal.app, navigate to the directory you want to clone ESP-IDF and clone it using \ngit clone\n command::\n\n\ncd ~/esp\ngit clone --recursive https://github.com/espressif/esp-idf.git\n\n\n\nESP-IDF will be downloaded into \n~/esp/esp-idf\n. \n\n\nNote the \n--recursive\n option! If you have already cloned ESP-IDF without this option, run another command to get all the submodules::\n\n\ncd ~/esp/esp-idf\ngit submodule update --init\n\n\n\nStep 3: Starting a project\n#\n\n\nESP-IDF by itself does not build a binary to run on the ESP32. The binary \u201capp\u201d comes from a project in a different directory. Multiple projects can share the same ESP-IDF directory.\n\n\nThe easiest way to start a project is to download the template project from GitHub::\n\n\ncd ~/esp\ngit clone https://github.com/espressif/esp-idf-template.git myapp\n\n\n\nThis will download \nesp-idf-template\n project into \n~/esp/myapp\n directory.\n\n\nIMPORTANT:\n The esp-idf build system does not support spaces in paths to esp-idf or to projects.\n\n\nStep 4: Building and flashing the application\n#\n\n\nIn Terminal.app, go to the application directory which was obtained on the previous step::\n\n\ncd ~/esp/myapp\n\n\n\nType a command like this to set the path to ESP-IDF directory:: \n\n\nexport IDF_PATH=~/esp/esp-idf\n\n\n\nAt this point you may configure the serial port to be used for uploading. Run::\n\n\nmake menuconfig\n\n\n\nThen navigate to \u201cSerial flasher config\u201d submenu and change value of \u201cDefault serial port\u201d to match the serial port you will use. Also take a moment to explore other options which are configurable in \nmenuconfig\n.\n\n\nIf you don\u2019t know device name for the  serial port of your development board, run this command two times, first with the board unplugged, then with the board plugged in. The port which appears the second time is the one you need::\n\n\nls /dev/tty.*\n\n\n\nNow you can build and flash the application. Run::\n\n\nmake flash\n\n\n\nThis will compile the application and all the ESP-IDF components, generate bootloader, partition table, and application binaries, and flash these binaries to your development board.\n\n\nFurther reading\n#\n\n\nIf you\u2019d like to use the Eclipse IDE instead of running \nmake\n, check out the Eclipse setup guide in this directory.",
            "title": "C\u00e0i \u0111\u1eb7t cho MacOS"
        },
        {
            "location": "/esp-idf/basic/install-macos/#step-0-prerequisites",
            "text": "",
            "title": "Step 0: Prerequisites"
        },
        {
            "location": "/esp-idf/basic/install-macos/#getting-macports-or-homebrew",
            "text": "Whether you compile the toolchain from source or download binary toolchain, there are some dependencies which need to be installed on macOS first. These dependencies are installed with one of the package managers: homebrew or MacPorts. If you have these already, you can skip the following instructions.   Install XCode from Mac App Store  Open Terminal.app and run  xcode-select --install  Run  sudo xcodebuild -license  and agree to XCode license  Install MacPorts_ or homebrew_   .. _homebrew: http://brew.sh/\n.. _MacPorts: https://www.macports.org/install.php",
            "title": "Getting MacPorts or homebrew"
        },
        {
            "location": "/esp-idf/basic/install-macos/#step-1-download-binary-toolchain-for-the-esp32",
            "text": "ESP32 toolchain for macOS is available for download from Espressif website:  https://dl.espressif.com/dl/xtensa-esp32-elf-osx-1.22.0-59.tar.gz  Download this file, then extract it to the location you prefer, for example::  mkdir -p ~/esp\ncd ~/esp\ntar -xzf ~/Downloads/xtensa-esp32-elf-osx-1.22.0-59.tar.gz  The toolchain will be extracted into  ~/esp/xtensa-esp32-elf/  directory.  To use it, you will need to update your  PATH  environment variable in  ~/.profile  file. To make  xtensa-esp32-elf  available for all terminal sessions, add the following line to your  ~/.profile  file::  export PATH=$PATH:$HOME/esp/xtensa-esp32-elf/bin  Alternatively, you may create an alias for the above command. This way you can get the toolchain only when you need it. To do this, add different line to your  ~/.profile  file::  alias get_esp32=\"export PATH=$PATH:$HOME/esp/xtensa-esp32-elf/bin\"  Then when you need the toolchain you can type  get_esp32  on the command line and the toolchain will be added to your  PATH .",
            "title": "Step 1: Download binary toolchain for the ESP32"
        },
        {
            "location": "/esp-idf/basic/install-macos/#alternative-step-1-compile-the-toolchain-from-source-using-crosstool-ng",
            "text": "Instead of downloading binary toolchain from Espressif website (Step 1 above) you may build the toolchain yourself.   If you can\u2019t think of a reason why you need to build it yourself, then probably it\u2019s better to stick with the binary version. However, here are some of the reasons why you might want to compile it from source:    if you want to customize toolchain build configuration    if you want to hack gcc or newlib or libstdc++    if you are curious and/or have time to spare    if you don\u2019t trust binaries downloaded from the Internet    In any case, here are the steps to compile the toolchain yourself.    Install dependencies:    with MacPorts::  sudo port install gsed gawk binutils gperf grep gettext ncurses    with homebrew ( TODO: provide list of packages for homebrew )    Create a case-sensitive filesystem image::  hdiutil create ~/esp/crosstool.dmg -volname \"ctng\" -size 10g -fs \"Case-sensitive HFS+\"  Mount it::  hdiutil mount ~/esp/crosstool.dmg  Create a symlink to your work directory::  cd ~/esp\nln -s /Volumes/ctng crosstool-NG  Download  crosstool-NG  and build it::  cd ~/esp\ngit clone -b xtensa-1.22.x https://github.com/espressif/crosstool-NG.git\ncd crosstool-NG\n./bootstrap && ./configure --prefix=$PWD && make install  Build the toolchain::  ./ct-ng xtensa-esp32-elf\n./ct-ng build\nchmod -R u+w builds/xtensa-esp32-elf  Toolchain will be built in  ~/esp/crosstool-NG/builds/xtensa-esp32-elf . Follow instructions given in the previous section to add the toolchain to your  PATH .",
            "title": "Alternative Step 1: Compile the toolchain from source using crosstool-NG"
        },
        {
            "location": "/esp-idf/basic/install-macos/#step-2-getting-esp-idf-from-github",
            "text": "Open Terminal.app, navigate to the directory you want to clone ESP-IDF and clone it using  git clone  command::  cd ~/esp\ngit clone --recursive https://github.com/espressif/esp-idf.git  ESP-IDF will be downloaded into  ~/esp/esp-idf .   Note the  --recursive  option! If you have already cloned ESP-IDF without this option, run another command to get all the submodules::  cd ~/esp/esp-idf\ngit submodule update --init",
            "title": "Step 2: Getting ESP-IDF from github"
        },
        {
            "location": "/esp-idf/basic/install-macos/#step-3-starting-a-project",
            "text": "ESP-IDF by itself does not build a binary to run on the ESP32. The binary \u201capp\u201d comes from a project in a different directory. Multiple projects can share the same ESP-IDF directory.  The easiest way to start a project is to download the template project from GitHub::  cd ~/esp\ngit clone https://github.com/espressif/esp-idf-template.git myapp  This will download  esp-idf-template  project into  ~/esp/myapp  directory.  IMPORTANT:  The esp-idf build system does not support spaces in paths to esp-idf or to projects.",
            "title": "Step 3: Starting a project"
        },
        {
            "location": "/esp-idf/basic/install-macos/#step-4-building-and-flashing-the-application",
            "text": "In Terminal.app, go to the application directory which was obtained on the previous step::  cd ~/esp/myapp  Type a command like this to set the path to ESP-IDF directory::   export IDF_PATH=~/esp/esp-idf  At this point you may configure the serial port to be used for uploading. Run::  make menuconfig  Then navigate to \u201cSerial flasher config\u201d submenu and change value of \u201cDefault serial port\u201d to match the serial port you will use. Also take a moment to explore other options which are configurable in  menuconfig .  If you don\u2019t know device name for the  serial port of your development board, run this command two times, first with the board unplugged, then with the board plugged in. The port which appears the second time is the one you need::  ls /dev/tty.*  Now you can build and flash the application. Run::  make flash  This will compile the application and all the ESP-IDF components, generate bootloader, partition table, and application binaries, and flash these binaries to your development board.",
            "title": "Step 4: Building and flashing the application"
        },
        {
            "location": "/esp-idf/basic/install-macos/#further-reading",
            "text": "If you\u2019d like to use the Eclipse IDE instead of running  make , check out the Eclipse setup guide in this directory.",
            "title": "Further reading"
        },
        {
            "location": "/esp-idf/basic/install-linux/",
            "text": "Step 0: Prerequisites\n#\n\n\nInstall some packages\n#\n\n\nTo compile with ESP-IDF you need to get the following packages:\n\n\n\n\n\n\nUbuntu and Debian::\n\n\nsudo apt-get install git wget make libncurses-dev flex bison gperf python python-serial \n\n\n\n\n\n\nArch::\n\n\nsudo pacman -S \u2013needed gcc git make ncurses flex bison gperf python2-pyserial\n\n\n\n\n\n\nStep 1: Download binary toolchain for the ESP32\n#\n\n\nESP32 toolchain for Linux is available for download from Espressif website:\n\n\n\n\n\n\nfor 64-bit Linux::\n\n\nhttps://dl.espressif.com/dl/xtensa-esp32-elf-linux64-1.22.0-59.tar.gz\n\n\n\n\n\n\nfor 32-bit Linux::\n\n\nhttps://dl.espressif.com/dl/xtensa-esp32-elf-linux32-1.22.0-59.tar.gz\n\n\n\n\n\n\nDownload this file, then extract it to the location you prefer, for example::\n\n\nmkdir -p ~/esp\ncd ~/esp\ntar -xzf ~/Downloads/xtensa-esp32-elf-linux64-1.22.0-59.tar.gz\n\n\n\nThe toolchain will be extracted into \n~/esp/xtensa-esp32-elf/\n directory.\n\n\nTo use it, you will need to update your \nPATH\n environment variable in \n~/.bash_profile\n file. To make \nxtensa-esp32-elf\n available for all terminal sessions, add the following line to your \n~/.bash_profile\n file::\n\n\nexport PATH=$PATH:$HOME/esp/xtensa-esp32-elf/bin\n\n\n\nAlternatively, you may create an alias for the above command. This way you can get the toolchain only when you need it. To do this, add different line to your \n~/.bash_profile\n file::\n\n\nalias get_esp32=\"export PATH=$PATH:$HOME/esp/xtensa-esp32-elf/bin\"\n\n\n\nThen when you need the toolchain you can type \nget_esp32\n on the command line and the toolchain will be added to your \nPATH\n.\n\n\nAlternative Step 1: Compile the toolchain from source using crosstool-NG\n#\n\n\nInstead of downloading binary toolchain from Espressif website (Step 1 above) you may build the toolchain yourself. \n\n\nIf you can\u2019t think of a reason why you need to build it yourself, then probably it\u2019s better to stick with the binary version. However, here are some of the reasons why you might want to compile it from source:\n\n\n\n\n\n\nif you want to customize toolchain build configuration\n\n\n\n\n\n\nif you want to hack gcc or newlib or libstdc++\n\n\n\n\n\n\nif you are curious and/or have time to spare\n\n\n\n\n\n\nif you don\u2019t trust binaries downloaded from the Internet\n\n\n\n\n\n\nIn any case, here are the steps to compile the toolchain yourself.\n\n\n\n\n\n\nInstall dependencies:\n\n\n\n\n\n\nUbuntu::\n\n\nsudo apt-get install gawk gperf grep gettext ncurses python python-dev automake bison flex texinfo help2man libtool\n\n\n\n\n\n\n\nDebian::\n\n\nTODO\n\n\n\n\n\n\n\nArch::\n\n\nTODO\n\n\n\n\n\n\n\nDownload \ncrosstool-NG\n and build it::\n\n\ncd ~/esp\ngit clone -b xtensa-1.22.x https://github.com/espressif/crosstool-NG.git\ncd crosstool-NG\n./bootstrap && ./configure --prefix=$PWD && make install\n\n\n\nBuild the toolchain::\n\n\n./ct-ng xtensa-esp32-elf\n./ct-ng build\nchmod -R u+w builds/xtensa-esp32-elf\n\n\n\nToolchain will be built in \n~/esp/crosstool-NG/builds/xtensa-esp32-elf\n. Follow instructions given in the previous section to add the toolchain to your \nPATH\n.\n\n\nStep 2: Getting ESP-IDF from github\n#\n\n\nOpen terminal, navigate to the directory you want to clone ESP-IDF and clone it using \ngit clone\n command::\n\n\ncd ~/esp\ngit clone --recursive https://github.com/espressif/esp-idf.git\n\n\n\nESP-IDF will be downloaded into \n~/esp/esp-idf\n. \n\n\nNote the \n--recursive\n option! If you have already cloned ESP-IDF without this option, run another command to get all the submodules::\n\n\ncd ~/esp/esp-idf\ngit submodule update --init\n\n\n\nIMPORTANT:\n The esp-idf build system does not support spaces in paths to esp-idf or to projects.\n\n\nStep 3: Starting a project\n#\n\n\nESP-IDF by itself does not build a binary to run on the ESP32. The binary \u201capp\u201d comes from a project in a different directory. Multiple projects can share the same ESP-IDF directory.\n\n\nThe easiest way to start a project is to download the template project from GitHub::\n\n\ncd ~/esp\ngit clone https://github.com/espressif/esp-idf-template.git myapp\n\n\n\nThis will download \nesp-idf-template\n project into \n~/esp/myapp\n directory.\n\n\nStep 4: Building and flashing the application\n#\n\n\nIn terminal, go to the application directory which was obtained on the previous step::\n\n\ncd ~/esp/myapp\n\n\n\nType a command like this to set the path to ESP-IDF directory:: \n\n\nexport IDF_PATH=~/esp/esp-idf\n\n\n\nAt this point you may configure the serial port to be used for uploading. Run::\n\n\nmake menuconfig\n\n\n\nThen navigate to \u201cSerial flasher config\u201d submenu and change value of \u201cDefault serial port\u201d to match the serial port you will use. Also take a moment to explore other options which are configurable in \nmenuconfig\n.\n\n\nSpecial note for Arch Linux users: navigate to \u201cSDK tool configuration\u201d and change the name of \u201cPython 2 interpreter\u201d from \npython\n to \npython2\n.\n\n\nNow you can build and flash the application. Run::\n\n\nmake flash\n\n\n\nThis will compile the application and all the ESP-IDF components, generate bootloader, partition table, and application binaries, and flash these binaries to your development board.\n\n\nFurther reading\n#\n\n\nIf you\u2019d like to use the Eclipse IDE instead of running \nmake\n, check out the Eclipse setup guide in this directory.",
            "title": "C\u00e0i \u0111\u1eb7t cho Linux"
        },
        {
            "location": "/esp-idf/basic/install-linux/#step-0-prerequisites",
            "text": "",
            "title": "Step 0: Prerequisites"
        },
        {
            "location": "/esp-idf/basic/install-linux/#install-some-packages",
            "text": "To compile with ESP-IDF you need to get the following packages:    Ubuntu and Debian::  sudo apt-get install git wget make libncurses-dev flex bison gperf python python-serial     Arch::  sudo pacman -S \u2013needed gcc git make ncurses flex bison gperf python2-pyserial",
            "title": "Install some packages"
        },
        {
            "location": "/esp-idf/basic/install-linux/#step-1-download-binary-toolchain-for-the-esp32",
            "text": "ESP32 toolchain for Linux is available for download from Espressif website:    for 64-bit Linux::  https://dl.espressif.com/dl/xtensa-esp32-elf-linux64-1.22.0-59.tar.gz    for 32-bit Linux::  https://dl.espressif.com/dl/xtensa-esp32-elf-linux32-1.22.0-59.tar.gz    Download this file, then extract it to the location you prefer, for example::  mkdir -p ~/esp\ncd ~/esp\ntar -xzf ~/Downloads/xtensa-esp32-elf-linux64-1.22.0-59.tar.gz  The toolchain will be extracted into  ~/esp/xtensa-esp32-elf/  directory.  To use it, you will need to update your  PATH  environment variable in  ~/.bash_profile  file. To make  xtensa-esp32-elf  available for all terminal sessions, add the following line to your  ~/.bash_profile  file::  export PATH=$PATH:$HOME/esp/xtensa-esp32-elf/bin  Alternatively, you may create an alias for the above command. This way you can get the toolchain only when you need it. To do this, add different line to your  ~/.bash_profile  file::  alias get_esp32=\"export PATH=$PATH:$HOME/esp/xtensa-esp32-elf/bin\"  Then when you need the toolchain you can type  get_esp32  on the command line and the toolchain will be added to your  PATH .",
            "title": "Step 1: Download binary toolchain for the ESP32"
        },
        {
            "location": "/esp-idf/basic/install-linux/#alternative-step-1-compile-the-toolchain-from-source-using-crosstool-ng",
            "text": "Instead of downloading binary toolchain from Espressif website (Step 1 above) you may build the toolchain yourself.   If you can\u2019t think of a reason why you need to build it yourself, then probably it\u2019s better to stick with the binary version. However, here are some of the reasons why you might want to compile it from source:    if you want to customize toolchain build configuration    if you want to hack gcc or newlib or libstdc++    if you are curious and/or have time to spare    if you don\u2019t trust binaries downloaded from the Internet    In any case, here are the steps to compile the toolchain yourself.    Install dependencies:    Ubuntu::  sudo apt-get install gawk gperf grep gettext ncurses python python-dev automake bison flex texinfo help2man libtool    Debian::  TODO    Arch::  TODO    Download  crosstool-NG  and build it::  cd ~/esp\ngit clone -b xtensa-1.22.x https://github.com/espressif/crosstool-NG.git\ncd crosstool-NG\n./bootstrap && ./configure --prefix=$PWD && make install  Build the toolchain::  ./ct-ng xtensa-esp32-elf\n./ct-ng build\nchmod -R u+w builds/xtensa-esp32-elf  Toolchain will be built in  ~/esp/crosstool-NG/builds/xtensa-esp32-elf . Follow instructions given in the previous section to add the toolchain to your  PATH .",
            "title": "Alternative Step 1: Compile the toolchain from source using crosstool-NG"
        },
        {
            "location": "/esp-idf/basic/install-linux/#step-2-getting-esp-idf-from-github",
            "text": "Open terminal, navigate to the directory you want to clone ESP-IDF and clone it using  git clone  command::  cd ~/esp\ngit clone --recursive https://github.com/espressif/esp-idf.git  ESP-IDF will be downloaded into  ~/esp/esp-idf .   Note the  --recursive  option! If you have already cloned ESP-IDF without this option, run another command to get all the submodules::  cd ~/esp/esp-idf\ngit submodule update --init  IMPORTANT:  The esp-idf build system does not support spaces in paths to esp-idf or to projects.",
            "title": "Step 2: Getting ESP-IDF from github"
        },
        {
            "location": "/esp-idf/basic/install-linux/#step-3-starting-a-project",
            "text": "ESP-IDF by itself does not build a binary to run on the ESP32. The binary \u201capp\u201d comes from a project in a different directory. Multiple projects can share the same ESP-IDF directory.  The easiest way to start a project is to download the template project from GitHub::  cd ~/esp\ngit clone https://github.com/espressif/esp-idf-template.git myapp  This will download  esp-idf-template  project into  ~/esp/myapp  directory.",
            "title": "Step 3: Starting a project"
        },
        {
            "location": "/esp-idf/basic/install-linux/#step-4-building-and-flashing-the-application",
            "text": "In terminal, go to the application directory which was obtained on the previous step::  cd ~/esp/myapp  Type a command like this to set the path to ESP-IDF directory::   export IDF_PATH=~/esp/esp-idf  At this point you may configure the serial port to be used for uploading. Run::  make menuconfig  Then navigate to \u201cSerial flasher config\u201d submenu and change value of \u201cDefault serial port\u201d to match the serial port you will use. Also take a moment to explore other options which are configurable in  menuconfig .  Special note for Arch Linux users: navigate to \u201cSDK tool configuration\u201d and change the name of \u201cPython 2 interpreter\u201d from  python  to  python2 .  Now you can build and flash the application. Run::  make flash  This will compile the application and all the ESP-IDF components, generate bootloader, partition table, and application binaries, and flash these binaries to your development board.",
            "title": "Step 4: Building and flashing the application"
        },
        {
            "location": "/esp-idf/basic/install-linux/#further-reading",
            "text": "If you\u2019d like to use the Eclipse IDE instead of running  make , check out the Eclipse setup guide in this directory.",
            "title": "Further reading"
        },
        {
            "location": "/esp-idf/basic/eclipse-setup/",
            "text": "Installing Eclipse IDE\n#\n\n\nThe Eclipse IDE gives you a graphical integrated development environment for writing, compiling and debugging ESP-IDF projects.\n\n\n\n\n\n\nStart by installing the esp-idf for your platform (see files in this directory with steps for Windows, OS X, Linux).\n\n\n\n\n\n\nDownload the Eclipse Installer for your platform from eclipse.org_.\n\n\n\n\n\n\nWhen running the Eclipse Installer, choose \u201cEclipse for C/C++ Development\u201d (in other places you\u2019ll see this referred to as CDT.)\n\n\n\n\n\n\nSetting up Eclipse\n#\n\n\nOnce your new Eclipse installation launches, follow these steps:\n\n\nImport New Project\n#\n\n\n\n\n\n\nEclipse makes use of the Makefile support in ESP-IDF. This means you need to start by creating an ESP-IDF project. You can use the skeleton project from github.\n\n\n\n\n\n\nOnce Eclipse is running, choose File -> Import\u2026\n\n\n\n\n\n\nIn the dialog that pops up, choose \u201cC/C++\u201d -> \u201cExisting Code as Makefile Project\u201d and click Next.\n\n\n\n\n\n\nOn the next page, enter \u201cExisting Code Location\u201d to be the directory of your IDF project. Don\u2019t specify the path to the ESP-IDF directory itself.\n\n\n\n\n\n\nOn the same page, under \u201cToolchain for Indexer Settings\u201d choose \u201cCross GCC\u201d. Then click Finish.\n\n\n\n\n\n\nProject Properties\n#\n\n\n\n\n\n\nThe new project will appear under Project Explorer. Right-click the project and choose Properties from the context menu.\n\n\n\n\n\n\nClick on the \u201cEnvironment\u201d properties page under \u201cC/C++ Build\u201d. Click \u201cAdd\u2026\u201d and enter name \nV\n and value \n1\n.\n\n\n\n\n\n\nClick \u201cAdd\u2026\u201d again, and enter name \nIDF_PATH\n. The value should be the full path where ESP-IDF is installed. \nWindows users: Use forward-slashes not backslashes for this path, ie C:/Users/MyUser/Development/esp-idf\n.\n\n\n\n\n\n\nWindows users only, follow these two additional steps:\n\n\n\n\n\n\nOn the same Environment property page, edit the PATH environment variable. Delete the existing value and replace it with \nC:\\msys32\\usr\\bin;C:\\msys32\\mingw32\\bin;C:\\msys32\\opt\\xtensa-esp32-elf\\bin\n (If you installed msys32 to a different directory then you\u2019ll need to change these paths to match).\n\n\n\n\n\n\nClick on the \u201cC/C++ Build\u201d top-level properties page then uncheck \u201cUse default build command\u201d and enter this for the custom build command: \nbash ${IDF_PATH}/tools/windows/eclipse_make.sh\n.\n\n\n\n\n\n\nAll users, continue with these steps:\n\n\nNavigate to \u201cC/C++ General\u201d -> \u201cPreprocessor Include Paths\u201d property page:\n\n\n\n\n\n\nClick the \u201cProviders\u201d tab\n\n\n\n\n\n\nIn the list of providers, click \u201cCDT Cross GCC Built-in Compiler Settings\u201d. Under \u201cCommand to get compiler specs\u201d, replace the text \n${COMMAND}\n at the beginning of the line with \nxtensa-esp32-elf-gcc\n. This means the full \u201cCommand to get compiler specs\u201d should be \nxtensa-esp32-elf-gcc ${FLAGS} -E -P -v -dD \"${INPUTS}\"\n.\n\n\n\n\n\n\nIn the list of providers, click \u201cCDT GCC Build Output Parser\u201d and type \nxtensa-esp32-elf-\n at the beginning of the Compiler command pattern. This means the full Compiler command pattern should be \nxtensa-esp32-elf-(g?cc)|([gc]\\+\\+)|(clang)\n\n\n\n\n\n\nClick OK to close the Properties dialog, and choose Project -> Build to build your project.\n\n\n\n\n\n\nFlash from Eclipse\n#\n\n\nYou can integrate the \u201cmake flash\u201d target into your Eclipse project to flash using esptool.py from the Eclipse UI:\n\n\n\n\n\n\nRight-click your project in Project Explorer (important to make sure you select the project, not a directory in the project, or Eclipse may find the wrong Makefile.)\n\n\n\n\n\n\nSelect Make Targets -> Create from the context menu.\n\n\n\n\n\n\nType \u201cflash\u201d as the target name. Leave the other options as their defaults.\n\n\n\n\n\n\nNow you can use Project -> Make Target -> Build (Shift+F9) to build the custom flash target, which will compile and flash the project.\n\n\n\n\n\n\nNote that you will need to use \u201cmake menuconfig\u201d to set the serial port and other config options for flashing. \u201cmake menuconfig\u201d still requires a command line terminal (see the instructions for your platform.)\n\n\nFollow the same steps to add \nbootloader\n and \npartition_table\n targets, if necessary.\n\n\n.. _eclipse.org: http://www.eclipse.org/\n\n\nEclipse Troubleshooting\n#\n\n\n\n\n*** Make was invoked from ... However please do not run make from the sdk or a component directory; ...\n - Eclipse will detect any directory with a Makefile in it as being a possible directory to run \u201cmake\u201d in. All component directories also contain a Makefile (the wrong one), so it is important when using Project -> Make Target to always select the top-level project directory in Project Explorer.",
            "title": "C\u00e0i \u0111\u1eb7t cho Eclipse"
        },
        {
            "location": "/esp-idf/basic/eclipse-setup/#installing-eclipse-ide",
            "text": "The Eclipse IDE gives you a graphical integrated development environment for writing, compiling and debugging ESP-IDF projects.    Start by installing the esp-idf for your platform (see files in this directory with steps for Windows, OS X, Linux).    Download the Eclipse Installer for your platform from eclipse.org_.    When running the Eclipse Installer, choose \u201cEclipse for C/C++ Development\u201d (in other places you\u2019ll see this referred to as CDT.)",
            "title": "Installing Eclipse IDE"
        },
        {
            "location": "/esp-idf/basic/eclipse-setup/#setting-up-eclipse",
            "text": "Once your new Eclipse installation launches, follow these steps:",
            "title": "Setting up Eclipse"
        },
        {
            "location": "/esp-idf/basic/eclipse-setup/#import-new-project",
            "text": "Eclipse makes use of the Makefile support in ESP-IDF. This means you need to start by creating an ESP-IDF project. You can use the skeleton project from github.    Once Eclipse is running, choose File -> Import\u2026    In the dialog that pops up, choose \u201cC/C++\u201d -> \u201cExisting Code as Makefile Project\u201d and click Next.    On the next page, enter \u201cExisting Code Location\u201d to be the directory of your IDF project. Don\u2019t specify the path to the ESP-IDF directory itself.    On the same page, under \u201cToolchain for Indexer Settings\u201d choose \u201cCross GCC\u201d. Then click Finish.",
            "title": "Import New Project"
        },
        {
            "location": "/esp-idf/basic/eclipse-setup/#project-properties",
            "text": "The new project will appear under Project Explorer. Right-click the project and choose Properties from the context menu.    Click on the \u201cEnvironment\u201d properties page under \u201cC/C++ Build\u201d. Click \u201cAdd\u2026\u201d and enter name  V  and value  1 .    Click \u201cAdd\u2026\u201d again, and enter name  IDF_PATH . The value should be the full path where ESP-IDF is installed.  Windows users: Use forward-slashes not backslashes for this path, ie C:/Users/MyUser/Development/esp-idf .    Windows users only, follow these two additional steps:    On the same Environment property page, edit the PATH environment variable. Delete the existing value and replace it with  C:\\msys32\\usr\\bin;C:\\msys32\\mingw32\\bin;C:\\msys32\\opt\\xtensa-esp32-elf\\bin  (If you installed msys32 to a different directory then you\u2019ll need to change these paths to match).    Click on the \u201cC/C++ Build\u201d top-level properties page then uncheck \u201cUse default build command\u201d and enter this for the custom build command:  bash ${IDF_PATH}/tools/windows/eclipse_make.sh .    All users, continue with these steps:  Navigate to \u201cC/C++ General\u201d -> \u201cPreprocessor Include Paths\u201d property page:    Click the \u201cProviders\u201d tab    In the list of providers, click \u201cCDT Cross GCC Built-in Compiler Settings\u201d. Under \u201cCommand to get compiler specs\u201d, replace the text  ${COMMAND}  at the beginning of the line with  xtensa-esp32-elf-gcc . This means the full \u201cCommand to get compiler specs\u201d should be  xtensa-esp32-elf-gcc ${FLAGS} -E -P -v -dD \"${INPUTS}\" .    In the list of providers, click \u201cCDT GCC Build Output Parser\u201d and type  xtensa-esp32-elf-  at the beginning of the Compiler command pattern. This means the full Compiler command pattern should be  xtensa-esp32-elf-(g?cc)|([gc]\\+\\+)|(clang)    Click OK to close the Properties dialog, and choose Project -> Build to build your project.",
            "title": "Project Properties"
        },
        {
            "location": "/esp-idf/basic/eclipse-setup/#flash-from-eclipse",
            "text": "You can integrate the \u201cmake flash\u201d target into your Eclipse project to flash using esptool.py from the Eclipse UI:    Right-click your project in Project Explorer (important to make sure you select the project, not a directory in the project, or Eclipse may find the wrong Makefile.)    Select Make Targets -> Create from the context menu.    Type \u201cflash\u201d as the target name. Leave the other options as their defaults.    Now you can use Project -> Make Target -> Build (Shift+F9) to build the custom flash target, which will compile and flash the project.    Note that you will need to use \u201cmake menuconfig\u201d to set the serial port and other config options for flashing. \u201cmake menuconfig\u201d still requires a command line terminal (see the instructions for your platform.)  Follow the same steps to add  bootloader  and  partition_table  targets, if necessary.  .. _eclipse.org: http://www.eclipse.org/",
            "title": "Flash from Eclipse"
        },
        {
            "location": "/esp-idf/basic/eclipse-setup/#eclipse-troubleshooting",
            "text": "*** Make was invoked from ... However please do not run make from the sdk or a component directory; ...  - Eclipse will detect any directory with a Makefile in it as being a possible directory to run \u201cmake\u201d in. All component directories also contain a Makefile (the wrong one), so it is important when using Project -> Make Target to always select the top-level project directory in Project Explorer.",
            "title": "Eclipse Troubleshooting"
        },
        {
            "location": "/esp-idf/basic/openocd/",
            "text": "OpenOCD setup for ESP32\n#\n\n\nThe ESP31 and ESP32 have two powerful Xtensa cores, allowing for a great deal of variety of program architectures. The FreeRTOS\nOS that comes with ESP-IDF is capable multi-core pre-emptive multithreading, allowing for an intuitive way of writing software. \n\n\nThe downside of the ease of programming is that debugging without the right tools is harder: figuring out a bug that is caused \nby two threads, maybe even running simultaneously on two different CPU cures, can take a long time when all you have are printf \nstatements. A better and in many cases quicker way to debug such problems is by using a debugger, connected to the processors over\na debug port. \n\n\nEspressif has ported OpenOCD to support the ESP32 processor and the multicore FreeRTOS that will be the foundation of most ESP32\napps, and has written some tools to help with features OpenOCD does not support natively. These are all available for free, and \nthis document describes how to install and use them.\n\n\nJTAG adapter hardware\n#\n\n\nYou will need a JTAG adapter that is compatible with both the voltage levels on the ESP32 as well as with the OpenOCD software. \nThe JTAG port on the ESP32 is an industry-standard JTAG port which lacks (and does not need) the TRST pin. The JTAG I/O pins\nall are powered from the VDD_3P3_RTC pin (which normally would be powered by a 3.3V rail) so the JTAG adapter needs to be\nable to work with JTAG pins in that voltage range. On the software side, OpenOCD supports a fair amount of JTAG adapters.\nSee http://openocd.org/doc/html/Debug-Adapter-Hardware.html for an (unfortunately slightly incomplete) list of the adapters \nOpenOCD works with. This page lists SWD-compatible adapters as well; take note that the ESP32 does not support SWD.\n\n\nAt Espressif, we have tested the TIAO USB Multi-protocol Adapter board as well as the Flyswatter2, which are both USB2.0 high-speed\ndevices and give a good throughput. We also tested a J-link-compatible and an EasyOpenJTAG adapter; both worked as well but are \nsomewhat slower.\n\n\nThe minimal signalling to get a working JTAG connection are TDI, TDO, TCK, TMS and Gnd. Some JTAG debuggers also need a connection \nfrom the ESP32 power line to a line called e.g. Vtar to set the working voltage. SRST can optionally be connected to the CH_PD of \nthe ESP32, although for now, support in OpenOCD for that line is pretty minimal.\n\n\nInstalling OpenOCD\n#\n\n\nThe sources for the ESP32-enabled variant of OpenOCD are available from \nEspressifs Github <https://github.com/espressif/openocd-esp32>\n_. \nTo download the source, use the following commands::\n\n\ngit clone https://github.com/espressif/openocd-esp32.git\ncd openocd-esp32\ngit submodule init\ngit submodule update\n\n\n\nFor compilation of OpenOCD, please refer to the README, README.OSX and README.Windows file in the openocd-esp32 directory. You can skip\nthe \nmake install\n step if you want.\n\n\nConfiguring the ESP32 target in OpenOCD\n#\n\n\nAfter OpenOCD is compiled (and optionally installed) and the JTAG adapter is connected to the ESP32 board, everything is ready to\ninvoke OpenOCD for the first time. To do this, OpenOCD needs to be told what JTAG adapter to use as well as what type of board\nand processor the JTAG adapter is connected to. It is the easiest to do both using a configuration file. A template configuration\nfile (esp32.cfg) is included in the same directory as this file. A way to use this would be:\n\n\n\n\nCopy esp32.cfg to the openocd-esp32 directory\n\n\nEdit the copied esp32.cfg file. Most importantly, change the \nsource [find interface/ftdi/tumpa.cfg]\n line to reflect the\n  physical JTAG adapter connected.\n\n\nOpen a terminal and \ncd\n to the openocd-esp32 directory.\n\n\nRun \n./src/openocd -s ./tcl -f ./esp32.cfg\n to start OpenOCD\n\n\n\n\nYou should now see something like this::\n\n\nuser@machine:~/esp32/openocd-esp32$ ./src/openocd -s ./tcl/ -f ../openocd-esp32-tools/esp32.cfg \nOpen On-Chip Debugger 0.10.0-dev-00446-g6e13a97-dirty (2016-08-23-16:36)\nLicensed under GNU GPL v2\nFor bug reports, read\nhttp://openocd.org/doc/doxygen/bugs.html\nnone separate\nadapter speed: 200 kHz\nInfo : clock speed 200 kHz\nInfo : JTAG tap: esp32.cpu0 tap/device found: 0x120034e5 (mfg: 0x272 (Tensilica), part: 0x2003, ver: 0x1)\nInfo : JTAG tap: esp32.cpu1 tap/device found: 0x120034e5 (mfg: 0x272 (Tensilica), part: 0x2003, ver: 0x1)\nInfo : esp32.cpu0: Debug controller was reset (pwrstat=0x5F, after clear 0x0F).\nInfo : esp32.cpu0: Core was reset (pwrstat=0x5F, after clear 0x0F).\n\n\n\n\n\nIf you see an error indicating permission problems, please see the \u2018Permissions delegation\u2019 bit in the OpenOCD README\n\n\nIf you see JTAG errors (\u2026all ones/\u2026all zeroes) please check your connections and see if everything is powered on.\n\n\n\n\nConnecting a debugger to OpenOCD\n#\n\n\nOpenOCD should now be ready to accept gdb connections. If you have compiled the ESP32 toolchain using Crosstool-NG, or\nif you have downloaded a precompiled toolchain from the Espressif website, you should already have xtensa-esp32-elf-gdb, \na version of gdb that can be used for this. First, make sure the project you want to debug is compiled and flashed \ninto the ESP32s SPI flash. Then, in a different console than OpenOCD is running in, invoke gdb. For example, for the \ntemplate app, you would do this like such::\n\n\ncd esp-idf-template\nxtensa-esp32-elf-gdb -ex 'target remote localhost:3333' ./build/app-template.elf\n\n\n\nThis should give you a gdb prompt.\n\n\nFreeRTOS support\n#\n\n\nOpenOCD has explicit support for the ESP-IDF FreeRTOS; FreeRTOS detection can be disabled in esp32.conf. When enabled,\ngdb can see FreeRTOS tasks as threads. Viewing them all can be done using the gdb \ni threads\n command, changing\nto a certain task is done with \nthread x\n, with x being the number of the thread. All threads can be switched to\nexcept for a thread actually running on the other CPU, please see \nESP32 quirks\n for more information.\n\n\nESP32 quirks\n#\n\n\nNormal gdb breakpoints (\nb myFunction\n) can only be set in IRAM, because that memory is writable. Setting these types of\nbreakpoints in code in flash will not work. Instead, use a hardware breakpoint (\nhb myFunction\n). The esp32 supports\n2 hardware breakpoints. It also supports two watchpoint, so two variables can be watched for change or read by the gdb\ncommand \nwatch myVariable\n.\n\n\nConnecting gdb to the APP or PRO cpu happens by changing the port gdb connects to. \ntarget remote localhost:3333\n connects\nto the PRO CPU, \ntarget remote localhost:3334\n to the APP CPU. Hardware-wise, when one CPU is halted because of debugging\nreasons, the other one will be halted as well; resuming also happens simultaneously.\n\n\nBecause gdb only sees the system from the point of view of the selected CPU, only the FreeRTOS tasks that are suspended\nand the task running on the CPU gdb is connected to, will be shown correctly. The task that was active on the other\ncpu can be inspected, but its state may be wildly inconsistent.\n\n\nThe ESP-IDF code has the option of compiling in various support options for OpenOCD: it can stop execution when the first \nthread is started and break the system if a panic or unhandled exception is thrown. Both options are enabled by default \nbut can be disabled using the esp-idf configuration menu. Please see the \nmake menuconfig\n menu for more details.\n\n\nNormally, under OpenOCD, a board can be reset by entering \u2018mon reset\u2019 or \u2018mon reset halt\u2019 into gdb. For\nthe ESP32, these commands work more or less, but have side effects. First of all, an OpenOCD reset only\nresets the CPU cores, not the peripherals, which may lead to undefined behaviour if software assumes the\nafter-reset state of peripherals. Secondly, \u2018mon reset halt\u2019 stops before FreeRTOS is initialized. \nOpenOCD assumes (in the default configuration, you can change this by editing esp32.cfg) a running \nFreeRTOS and may get confused.",
            "title": "S\u1eed d\u1ee5ng OpenOCD"
        },
        {
            "location": "/esp-idf/basic/openocd/#openocd-setup-for-esp32",
            "text": "The ESP31 and ESP32 have two powerful Xtensa cores, allowing for a great deal of variety of program architectures. The FreeRTOS\nOS that comes with ESP-IDF is capable multi-core pre-emptive multithreading, allowing for an intuitive way of writing software.   The downside of the ease of programming is that debugging without the right tools is harder: figuring out a bug that is caused \nby two threads, maybe even running simultaneously on two different CPU cures, can take a long time when all you have are printf \nstatements. A better and in many cases quicker way to debug such problems is by using a debugger, connected to the processors over\na debug port.   Espressif has ported OpenOCD to support the ESP32 processor and the multicore FreeRTOS that will be the foundation of most ESP32\napps, and has written some tools to help with features OpenOCD does not support natively. These are all available for free, and \nthis document describes how to install and use them.",
            "title": "OpenOCD setup for ESP32"
        },
        {
            "location": "/esp-idf/basic/openocd/#jtag-adapter-hardware",
            "text": "You will need a JTAG adapter that is compatible with both the voltage levels on the ESP32 as well as with the OpenOCD software. \nThe JTAG port on the ESP32 is an industry-standard JTAG port which lacks (and does not need) the TRST pin. The JTAG I/O pins\nall are powered from the VDD_3P3_RTC pin (which normally would be powered by a 3.3V rail) so the JTAG adapter needs to be\nable to work with JTAG pins in that voltage range. On the software side, OpenOCD supports a fair amount of JTAG adapters.\nSee http://openocd.org/doc/html/Debug-Adapter-Hardware.html for an (unfortunately slightly incomplete) list of the adapters \nOpenOCD works with. This page lists SWD-compatible adapters as well; take note that the ESP32 does not support SWD.  At Espressif, we have tested the TIAO USB Multi-protocol Adapter board as well as the Flyswatter2, which are both USB2.0 high-speed\ndevices and give a good throughput. We also tested a J-link-compatible and an EasyOpenJTAG adapter; both worked as well but are \nsomewhat slower.  The minimal signalling to get a working JTAG connection are TDI, TDO, TCK, TMS and Gnd. Some JTAG debuggers also need a connection \nfrom the ESP32 power line to a line called e.g. Vtar to set the working voltage. SRST can optionally be connected to the CH_PD of \nthe ESP32, although for now, support in OpenOCD for that line is pretty minimal.",
            "title": "JTAG adapter hardware"
        },
        {
            "location": "/esp-idf/basic/openocd/#installing-openocd",
            "text": "The sources for the ESP32-enabled variant of OpenOCD are available from  Espressifs Github <https://github.com/espressif/openocd-esp32> _. \nTo download the source, use the following commands::  git clone https://github.com/espressif/openocd-esp32.git\ncd openocd-esp32\ngit submodule init\ngit submodule update  For compilation of OpenOCD, please refer to the README, README.OSX and README.Windows file in the openocd-esp32 directory. You can skip\nthe  make install  step if you want.",
            "title": "Installing OpenOCD"
        },
        {
            "location": "/esp-idf/basic/openocd/#configuring-the-esp32-target-in-openocd",
            "text": "After OpenOCD is compiled (and optionally installed) and the JTAG adapter is connected to the ESP32 board, everything is ready to\ninvoke OpenOCD for the first time. To do this, OpenOCD needs to be told what JTAG adapter to use as well as what type of board\nand processor the JTAG adapter is connected to. It is the easiest to do both using a configuration file. A template configuration\nfile (esp32.cfg) is included in the same directory as this file. A way to use this would be:   Copy esp32.cfg to the openocd-esp32 directory  Edit the copied esp32.cfg file. Most importantly, change the  source [find interface/ftdi/tumpa.cfg]  line to reflect the\n  physical JTAG adapter connected.  Open a terminal and  cd  to the openocd-esp32 directory.  Run  ./src/openocd -s ./tcl -f ./esp32.cfg  to start OpenOCD   You should now see something like this::  user@machine:~/esp32/openocd-esp32$ ./src/openocd -s ./tcl/ -f ../openocd-esp32-tools/esp32.cfg \nOpen On-Chip Debugger 0.10.0-dev-00446-g6e13a97-dirty (2016-08-23-16:36)\nLicensed under GNU GPL v2\nFor bug reports, read\nhttp://openocd.org/doc/doxygen/bugs.html\nnone separate\nadapter speed: 200 kHz\nInfo : clock speed 200 kHz\nInfo : JTAG tap: esp32.cpu0 tap/device found: 0x120034e5 (mfg: 0x272 (Tensilica), part: 0x2003, ver: 0x1)\nInfo : JTAG tap: esp32.cpu1 tap/device found: 0x120034e5 (mfg: 0x272 (Tensilica), part: 0x2003, ver: 0x1)\nInfo : esp32.cpu0: Debug controller was reset (pwrstat=0x5F, after clear 0x0F).\nInfo : esp32.cpu0: Core was reset (pwrstat=0x5F, after clear 0x0F).   If you see an error indicating permission problems, please see the \u2018Permissions delegation\u2019 bit in the OpenOCD README  If you see JTAG errors (\u2026all ones/\u2026all zeroes) please check your connections and see if everything is powered on.",
            "title": "Configuring the ESP32 target in OpenOCD"
        },
        {
            "location": "/esp-idf/basic/openocd/#connecting-a-debugger-to-openocd",
            "text": "OpenOCD should now be ready to accept gdb connections. If you have compiled the ESP32 toolchain using Crosstool-NG, or\nif you have downloaded a precompiled toolchain from the Espressif website, you should already have xtensa-esp32-elf-gdb, \na version of gdb that can be used for this. First, make sure the project you want to debug is compiled and flashed \ninto the ESP32s SPI flash. Then, in a different console than OpenOCD is running in, invoke gdb. For example, for the \ntemplate app, you would do this like such::  cd esp-idf-template\nxtensa-esp32-elf-gdb -ex 'target remote localhost:3333' ./build/app-template.elf  This should give you a gdb prompt.",
            "title": "Connecting a debugger to OpenOCD"
        },
        {
            "location": "/esp-idf/basic/openocd/#freertos-support",
            "text": "OpenOCD has explicit support for the ESP-IDF FreeRTOS; FreeRTOS detection can be disabled in esp32.conf. When enabled,\ngdb can see FreeRTOS tasks as threads. Viewing them all can be done using the gdb  i threads  command, changing\nto a certain task is done with  thread x , with x being the number of the thread. All threads can be switched to\nexcept for a thread actually running on the other CPU, please see  ESP32 quirks  for more information.",
            "title": "FreeRTOS support"
        },
        {
            "location": "/esp-idf/basic/openocd/#esp32-quirks",
            "text": "Normal gdb breakpoints ( b myFunction ) can only be set in IRAM, because that memory is writable. Setting these types of\nbreakpoints in code in flash will not work. Instead, use a hardware breakpoint ( hb myFunction ). The esp32 supports\n2 hardware breakpoints. It also supports two watchpoint, so two variables can be watched for change or read by the gdb\ncommand  watch myVariable .  Connecting gdb to the APP or PRO cpu happens by changing the port gdb connects to.  target remote localhost:3333  connects\nto the PRO CPU,  target remote localhost:3334  to the APP CPU. Hardware-wise, when one CPU is halted because of debugging\nreasons, the other one will be halted as well; resuming also happens simultaneously.  Because gdb only sees the system from the point of view of the selected CPU, only the FreeRTOS tasks that are suspended\nand the task running on the CPU gdb is connected to, will be shown correctly. The task that was active on the other\ncpu can be inspected, but its state may be wildly inconsistent.  The ESP-IDF code has the option of compiling in various support options for OpenOCD: it can stop execution when the first \nthread is started and break the system if a panic or unhandled exception is thrown. Both options are enabled by default \nbut can be disabled using the esp-idf configuration menu. Please see the  make menuconfig  menu for more details.  Normally, under OpenOCD, a board can be reset by entering \u2018mon reset\u2019 or \u2018mon reset halt\u2019 into gdb. For\nthe ESP32, these commands work more or less, but have side effects. First of all, an OpenOCD reset only\nresets the CPU cores, not the peripherals, which may lead to undefined behaviour if software assumes the\nafter-reset state of peripherals. Secondly, \u2018mon reset halt\u2019 stops before FreeRTOS is initialized. \nOpenOCD assumes (in the default configuration, you can change this by editing esp32.cfg) a running \nFreeRTOS and may get confused.",
            "title": "ESP32 quirks"
        },
        {
            "location": "/esp-idf/basic/partition-tables/",
            "text": "Partition Tables\n#\n\n\nA single ESP32\u2019s flash can contain multiple apps, as well as many different kinds of data (calibration data, filesystems, parameter storage, etc). For this reason a partition table is flashed to offset 0x4000 in the flash.\n\n\nEach entry in the partition table has a name (label), type (app, data, or something else), subtype and the offset in flash where the partition is loaded.\n\n\nThe simplest way to use the partition table is to \nmake menuconfig\n and choose one of the simple predefined partition tables:\n\n\n\n\n\u201cSingle factory app, no OTA\u201d\n\n\n\u201cFactory app, two OTA definitions\u201d\n\n\n\n\nIn both cases the factory app is flashed at offset 0x10000. If you \nmake partition_table\n then it will print a summary of the partition table.\n\n\nKnown Issues\n#\n\n\nThe below design document outlines the goals for the partition table system. At the moment, only some features are used:\n\n\n\n\ndata partition types \u201crf\u201d & \u201cwifi\u201d are unused and can be entirely omitted to save space.\n\n\nNVS (non-volatile-storage) uses a hardcoded 12KB (0x3000 byte) region at offset 0x6000.\n\n\n\n\nOnce a full user API is in place for partition access, these limitations will be resolved and you\u2019ll be able to use the partition mechanism fully for storing data in flash.\n\n\nBuilt-in Partition Tables\n#\n\n\nHere is the summary printed for the \u201cSingle factory app, no OTA\u201d configuration::\n\n\n# Espressif ESP32 Partition Table\n  # Name,  Type, SubType, Offset,  Size\n  factory, app,  factory, 0x10000, 1M\n  rfdata,  data, rf,     0x110000, 256K\n  wifidata,data, wifi,   0x150000, 256K\n\n\n\n\nAt a 0x10000 (64KB) offset in the flash is the app labelled \u201cfactory\u201d. The bootloader will run this app by default.\n\n\nThere are also two data regions defined in the partition table for storing RF & Wifi calibration data.\n\n\n\n\nHere is the summary printed for the \u201cFactory app, two OTA definitions\u201d configuration::\n\n\n# Espressif ESP32 Partition Table\n  # Name,  Type, SubType, Offset,  Size\n  factory, app,  factory,  0x10000, 1M\n  ota_0,   app,  ota_0,   0x110000, 1M\n  ota_1,   app,  ota_1,   0x210000, 1M\n  rfdata,  data, rf,      0x310000, 256K\n  wifidata,data, wifi,    0x350000, 256K\n  otadata, data, ota,     0x390000, 256K\n\n\n\n\nThere are now three app partition definitions.\n\n\nThe type of all three are set as \u201capp\u201d, but the subtype varies between the factory app at 0x10000 and the next two \u201cOTA\u201d apps.\n\n\nThere is also a new \u201cota data\u201d slot, which holds the data for OTA updates. The bootloader consults this data in order to know which app to execute. If \u201cota data\u201d is empty, it will execute the factory app.\n\n\n\n\nCreating Custom Tables\n#\n\n\nIf you choose \u201cCustom partition table CSV\u201d in menuconfig then you can also enter the name of a CSV file (in the project directory) to use for your partition table. The CSV file can describe any number of definitions for the table you need.\n\n\nThe CSV format is the same format as printed in the summaries shown above. However, not all fields are required in the CSV. For example, here is the \u201cinput\u201d CSV for the OTA partition table::\n\n\n# Name,   Type, SubType, Offset,   Size\n  factory,  app,  factory, 0x10000,  1M\n  ota_0,    app,  ota_0,   ,         1M\n  ota_1,    app,  ota_1,   ,         1M\n  rfdata,   data, rf,      ,         256K\n  wifidata, data, wifi,    ,         256K\n  otadata,  data, ota,     ,         256K\n\n\n\n\nWhitespace between fields is ignored, and so is any line starting with # (comments).\n\n\nEach non-comment line in the CSV file is a partition definition.\n\n\nOnly the offset for the first partition is supplied. The gen_esp32part.py tool fills in each remaining offset to start after the preceding partition.\n\n\n\n\nName field\n\n\n\nName field can be any meaningful name. It is not significant to the ESP32. Names longer than 16 characters will be truncated.\n\nType field\n\n\n\n\nType field can be specified as app (0) or data (1). Or it can be a number 0-254 (or as hex 0x00-0xFE). Types 0x00-0x3F are reserved for Espressif. If your application needs to store data, please add a custom partition type in the range 0x40-0xFE.\n\n\nThe bootloader ignores any types other than 0 & 1.\n\n\nSubtype\n~~~~~~~\n\n\nWhen type is \u201capp\u201d, the subtype field can be specified as factory (0), ota_0 (0x10) \u2026 ota_15 (0x1F) and test (0x20). Or it can be any number 0-255 (0x00-0xFF). The bootloader will execute the factory app unless there it sees a partition of type data/ota, in which case it reads this partition to determine which OTA image to boot\n\n\nWhen type is \u201cdata\u201d, the subtype field can be specified as ota (0), rf (1), wifi (2). Or it can be a number 0x00-0xFF. The bootloader ignores all data subtypes except for ota. Other \u201cdata\u201d subtypes are reserved for Espressif use. To create custom data partition subtypes then use a custom type value, and choose any subtype 0x00-0xFF.\n\n\nOffset & Size\n~~~~~~~~~~~~~\n\n\nOnly the first offset field is required (we recommend using 0x10000). Partitions with blank offsets will start after the previous partition.\n\n\nApp partitions have to be at offsets aligned to 0x10000 (64K). If you leave the offset field blank, the tool will automatically align the partition. If you specify an unaligned offset for an app partition, the tool will return an error.\n\n\nSizes and offsets can be specified as decimal numbers, hex numbers with the prefix 0x, or size multipliers M or K (1024 and 1024*1024 bytes).\n\n\nGenerating Binary Partition Table\n#\n\n\nThe partition table which is flashed to the ESP32 is in a binary format, not CSV. The tool bin/gen_esp32part.py is used to convert between CSV and binary formats.\n\n\nIf you configure the partition table CSV name in \nmake menuconfig\n and then \nmake partition_table\n, this conversion is done for you.\n\n\nTo convert CSV to Binary manually::\n\n\npython bin/gen_esp32part.py \u2013verify input_partitions.csv binary_partitions.bin\n\n\nTo convert binary format back to CSV::\n\n\npython bin/gen_esp32part.py \u2013verify binary_partitions.bin input_partitions.csv\n\n\nTo display the contents of a binary partition table on stdout (this is how the summaries displayed when running \nmake partition_table\n are generated::\n\n\npython bin/gen_esp32part.py binary_partitions.bin\n\n\ngen_esp32part.py\n takes one optional argument, \n--verify\n, which will also verify the partition table during conversion (checking for overlapping partitions, unaligned partitions, etc.)\n\n\nFlashing the partition table\n#\n\n\n\n\nmake partition_table-flash\n: will flash the partition table with esptool.py.\n\n\nmake flash\n: Will flash everything including the partition table.\n\n\n\n\nA manual flashing command is also printed as part of \nmake partition_table\n.",
            "title": "Partition Tables"
        },
        {
            "location": "/esp-idf/basic/partition-tables/#partition-tables",
            "text": "A single ESP32\u2019s flash can contain multiple apps, as well as many different kinds of data (calibration data, filesystems, parameter storage, etc). For this reason a partition table is flashed to offset 0x4000 in the flash.  Each entry in the partition table has a name (label), type (app, data, or something else), subtype and the offset in flash where the partition is loaded.  The simplest way to use the partition table is to  make menuconfig  and choose one of the simple predefined partition tables:   \u201cSingle factory app, no OTA\u201d  \u201cFactory app, two OTA definitions\u201d   In both cases the factory app is flashed at offset 0x10000. If you  make partition_table  then it will print a summary of the partition table.",
            "title": "Partition Tables"
        },
        {
            "location": "/esp-idf/basic/partition-tables/#known-issues",
            "text": "The below design document outlines the goals for the partition table system. At the moment, only some features are used:   data partition types \u201crf\u201d & \u201cwifi\u201d are unused and can be entirely omitted to save space.  NVS (non-volatile-storage) uses a hardcoded 12KB (0x3000 byte) region at offset 0x6000.   Once a full user API is in place for partition access, these limitations will be resolved and you\u2019ll be able to use the partition mechanism fully for storing data in flash.",
            "title": "Known Issues"
        },
        {
            "location": "/esp-idf/basic/partition-tables/#built-in-partition-tables",
            "text": "Here is the summary printed for the \u201cSingle factory app, no OTA\u201d configuration::  # Espressif ESP32 Partition Table\n  # Name,  Type, SubType, Offset,  Size\n  factory, app,  factory, 0x10000, 1M\n  rfdata,  data, rf,     0x110000, 256K\n  wifidata,data, wifi,   0x150000, 256K   At a 0x10000 (64KB) offset in the flash is the app labelled \u201cfactory\u201d. The bootloader will run this app by default.  There are also two data regions defined in the partition table for storing RF & Wifi calibration data.   Here is the summary printed for the \u201cFactory app, two OTA definitions\u201d configuration::  # Espressif ESP32 Partition Table\n  # Name,  Type, SubType, Offset,  Size\n  factory, app,  factory,  0x10000, 1M\n  ota_0,   app,  ota_0,   0x110000, 1M\n  ota_1,   app,  ota_1,   0x210000, 1M\n  rfdata,  data, rf,      0x310000, 256K\n  wifidata,data, wifi,    0x350000, 256K\n  otadata, data, ota,     0x390000, 256K   There are now three app partition definitions.  The type of all three are set as \u201capp\u201d, but the subtype varies between the factory app at 0x10000 and the next two \u201cOTA\u201d apps.  There is also a new \u201cota data\u201d slot, which holds the data for OTA updates. The bootloader consults this data in order to know which app to execute. If \u201cota data\u201d is empty, it will execute the factory app.",
            "title": "Built-in Partition Tables"
        },
        {
            "location": "/esp-idf/basic/partition-tables/#creating-custom-tables",
            "text": "If you choose \u201cCustom partition table CSV\u201d in menuconfig then you can also enter the name of a CSV file (in the project directory) to use for your partition table. The CSV file can describe any number of definitions for the table you need.  The CSV format is the same format as printed in the summaries shown above. However, not all fields are required in the CSV. For example, here is the \u201cinput\u201d CSV for the OTA partition table::  # Name,   Type, SubType, Offset,   Size\n  factory,  app,  factory, 0x10000,  1M\n  ota_0,    app,  ota_0,   ,         1M\n  ota_1,    app,  ota_1,   ,         1M\n  rfdata,   data, rf,      ,         256K\n  wifidata, data, wifi,    ,         256K\n  otadata,  data, ota,     ,         256K   Whitespace between fields is ignored, and so is any line starting with # (comments).  Each non-comment line in the CSV file is a partition definition.  Only the offset for the first partition is supplied. The gen_esp32part.py tool fills in each remaining offset to start after the preceding partition.   Name field  \nName field can be any meaningful name. It is not significant to the ESP32. Names longer than 16 characters will be truncated.\n\nType field  Type field can be specified as app (0) or data (1). Or it can be a number 0-254 (or as hex 0x00-0xFE). Types 0x00-0x3F are reserved for Espressif. If your application needs to store data, please add a custom partition type in the range 0x40-0xFE.  The bootloader ignores any types other than 0 & 1.  Subtype\n~~~~~~~  When type is \u201capp\u201d, the subtype field can be specified as factory (0), ota_0 (0x10) \u2026 ota_15 (0x1F) and test (0x20). Or it can be any number 0-255 (0x00-0xFF). The bootloader will execute the factory app unless there it sees a partition of type data/ota, in which case it reads this partition to determine which OTA image to boot  When type is \u201cdata\u201d, the subtype field can be specified as ota (0), rf (1), wifi (2). Or it can be a number 0x00-0xFF. The bootloader ignores all data subtypes except for ota. Other \u201cdata\u201d subtypes are reserved for Espressif use. To create custom data partition subtypes then use a custom type value, and choose any subtype 0x00-0xFF.  Offset & Size\n~~~~~~~~~~~~~  Only the first offset field is required (we recommend using 0x10000). Partitions with blank offsets will start after the previous partition.  App partitions have to be at offsets aligned to 0x10000 (64K). If you leave the offset field blank, the tool will automatically align the partition. If you specify an unaligned offset for an app partition, the tool will return an error.  Sizes and offsets can be specified as decimal numbers, hex numbers with the prefix 0x, or size multipliers M or K (1024 and 1024*1024 bytes).",
            "title": "Creating Custom Tables"
        },
        {
            "location": "/esp-idf/basic/partition-tables/#generating-binary-partition-table",
            "text": "The partition table which is flashed to the ESP32 is in a binary format, not CSV. The tool bin/gen_esp32part.py is used to convert between CSV and binary formats.  If you configure the partition table CSV name in  make menuconfig  and then  make partition_table , this conversion is done for you.  To convert CSV to Binary manually::  python bin/gen_esp32part.py \u2013verify input_partitions.csv binary_partitions.bin  To convert binary format back to CSV::  python bin/gen_esp32part.py \u2013verify binary_partitions.bin input_partitions.csv  To display the contents of a binary partition table on stdout (this is how the summaries displayed when running  make partition_table  are generated::  python bin/gen_esp32part.py binary_partitions.bin  gen_esp32part.py  takes one optional argument,  --verify , which will also verify the partition table during conversion (checking for overlapping partitions, unaligned partitions, etc.)",
            "title": "Generating Binary Partition Table"
        },
        {
            "location": "/esp-idf/basic/partition-tables/#flashing-the-partition-table",
            "text": "make partition_table-flash : will flash the partition table with esptool.py.  make flash : Will flash everything including the partition table.   A manual flashing command is also printed as part of  make partition_table .",
            "title": "Flashing the partition table"
        },
        {
            "location": "/projects/project-list/",
            "text": "C\u00e1c d\u1ef1 \u00e1n\n#",
            "title": "C\u00e1c d\u1ef1 \u00e1n"
        },
        {
            "location": "/projects/project-list/#cac-du-an",
            "text": "",
            "title": "C\u00e1c d\u1ef1 \u00e1n"
        },
        {
            "location": "/license/",
            "text": "B\u1ea3n quy\u1ec1n\n#\n\n\nTo\u00e0n b\u1ed9 t\u00e0i li\u1ec7u \u0111\u01b0\u1ee3c ph\u00e2n ph\u1ed1i theo gi\u1ea5y ph\u00e9p CC BY-SA-NC\n\n\nGhi nh\u00e2\u0323n \u0111o\u0301ng go\u0301p Phi Th\u01b0\u01a1ng ma\u0323i Chia se\u0309 v\u01a1\u0301i \u0110i\u00ea\u0300u ki\u00ea\u0323n Nh\u01b0 nhau (cc by-nc-sa):\nGi\u00e2\u0301y phe\u0301p na\u0300y cho phe\u0301p ng\u01b0\u01a1\u0300i kha\u0301c ph\u00f4\u0301i la\u0323i, tu\u0300y chi\u0309nh, va\u0300 x\u00e2y d\u01b0\u0323ng d\u01b0\u0323a tr\u00ean ta\u0301c ph\u00e2\u0309m cu\u0309a Ba\u0323n v\u01a1\u0301i mu\u0323c \u0111i\u0301ch Phi Th\u01b0\u01a1ng ma\u0323i, v\u01a1\u0301i \u0111i\u00ea\u0300u ki\u00ea\u0323n chu\u0301ng n\u00e2ng cao uy ti\u0301n cu\u0309a Ba\u0323n v\u00e0 cho phe\u0301p c\u00e2\u0301p phe\u0301p \u0111\u00f4\u0301i v\u01a1\u0301i ca\u0301c ta\u0301c ph\u00e2\u0309m sa\u0301ng ta\u0323o m\u01a1\u0301i cu\u0309a ho\u0323 theo ca\u0301c \u0111i\u00ea\u0300u khoa\u0309n gi\u00f4\u0301ng h\u00ea\u0323t.",
            "title": "B\u1ea3n quy\u1ec1n"
        },
        {
            "location": "/license/#ban-quyen",
            "text": "To\u00e0n b\u1ed9 t\u00e0i li\u1ec7u \u0111\u01b0\u1ee3c ph\u00e2n ph\u1ed1i theo gi\u1ea5y ph\u00e9p CC BY-SA-NC  Ghi nh\u00e2\u0323n \u0111o\u0301ng go\u0301p Phi Th\u01b0\u01a1ng ma\u0323i Chia se\u0309 v\u01a1\u0301i \u0110i\u00ea\u0300u ki\u00ea\u0323n Nh\u01b0 nhau (cc by-nc-sa):\nGi\u00e2\u0301y phe\u0301p na\u0300y cho phe\u0301p ng\u01b0\u01a1\u0300i kha\u0301c ph\u00f4\u0301i la\u0323i, tu\u0300y chi\u0309nh, va\u0300 x\u00e2y d\u01b0\u0323ng d\u01b0\u0323a tr\u00ean ta\u0301c ph\u00e2\u0309m cu\u0309a Ba\u0323n v\u01a1\u0301i mu\u0323c \u0111i\u0301ch Phi Th\u01b0\u01a1ng ma\u0323i, v\u01a1\u0301i \u0111i\u00ea\u0300u ki\u00ea\u0323n chu\u0301ng n\u00e2ng cao uy ti\u0301n cu\u0309a Ba\u0323n v\u00e0 cho phe\u0301p c\u00e2\u0301p phe\u0301p \u0111\u00f4\u0301i v\u01a1\u0301i ca\u0301c ta\u0301c ph\u00e2\u0309m sa\u0301ng ta\u0323o m\u01a1\u0301i cu\u0309a ho\u0323 theo ca\u0301c \u0111i\u00ea\u0300u khoa\u0309n gi\u00f4\u0301ng h\u00ea\u0323t.",
            "title": "B\u1ea3n quy\u1ec1n"
        },
        {
            "location": "/contributor/",
            "text": "Danh s\u00e1ch th\u00e0nh vi\u00ean \u0111\u00f3ng g\u00f3p:\n#\n\n\n\n\nTu\u1ea5n PM",
            "title": "\u0110\u00f3ng g\u00f3p"
        },
        {
            "location": "/contributor/#danh-sach-thanh-vien-ong-gop",
            "text": "Tu\u1ea5n PM",
            "title": "Danh s\u00e1ch th\u00e0nh vi\u00ean \u0111\u00f3ng g\u00f3p:"
        }
    ]
}